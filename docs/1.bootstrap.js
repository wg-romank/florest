(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[1],{

/***/ "./node_modules/uil/build/uil.module.js":
/*!**********************************************!*\
  !*** ./node_modules/uil/build/uil.module.js ***!
  \**********************************************/
/*! exports provided: Files, Gui, Proto, REVISION, Tools, add */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Files\", function() { return Files; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Gui\", function() { return Gui; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Proto\", function() { return Proto; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REVISION\", function() { return REVISION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Tools\", function() { return Tools; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/**\n * @license\n * Copyright 2010-2021 Uil.js Authors\n * SPDX-License-Identifier: MIT\n */\n/**\r\n * @author lth / https://github.com/lo-th\r\n */\r\n\r\n// INTENAL FUNCTION\r\n\r\nconst R = {\r\n\r\n\tui: [],\r\n\r\n    dom:null,\r\n\r\n\tID: null,\r\n    lock:false,\r\n    wlock:false,\r\n    current:-1,\r\n\r\n\tneedReZone: true,\r\n\tisEventsInit: false,\r\n    isLeave:false,\r\n\r\n    downTime:0,\r\n    prevTime:0,\r\n\r\n    prevDefault: ['contextmenu', 'wheel'],\r\n    pointerEvent: ['pointerdown', 'pointermove', 'pointerup'],\r\n    eventOut: ['pointercancel', 'pointerout', 'pointerleave'],\r\n\r\n\txmlserializer: null,\r\n\ttmpTime: null,\r\n    tmpImage: null,\r\n\r\n    oldCursor:'auto',\r\n\r\n    input: null,\r\n    parent: null,\r\n    firstImput: true,\r\n    \r\n    hiddenImput:null,\r\n    hiddenSizer:null,\r\n    hasFocus:false,\r\n    startInput:false,\r\n    inputRange : [0,0],\r\n    cursorId : 0,\r\n    str:'',\r\n    pos:0,\r\n    startX:-1,\r\n    moveX:-1,\r\n\r\n    debugInput:false,\r\n\r\n    isLoop: false,\r\n    listens: [],\r\n\r\n    e:{\r\n        type:null,\r\n        clientX:0,\r\n        clientY:0,\r\n        keyCode:NaN,\r\n        key:null,\r\n        delta:0,\r\n    },\r\n\r\n    isMobile: false,\r\n\r\n    now: null,\r\n\r\n    getTime: function() {\r\n        return ( self.performance && self.performance.now ) ? self.performance.now.bind( performance ) : Date.now;\r\n    },\r\n\r\n\tadd: function ( o ) {\r\n\r\n        R.ui.push( o );\r\n        R.getZone( o );\r\n\r\n        if( !R.isEventsInit ) R.initEvents();\r\n\r\n    },\r\n\r\n    testMobile: function () {\r\n\r\n        let n = navigator.userAgent;\r\n        if (n.match(/Android/i) || n.match(/webOS/i) || n.match(/iPhone/i) || n.match(/iPad/i) || n.match(/iPod/i) || n.match(/BlackBerry/i) || n.match(/Windows Phone/i)) return true;\r\n        else return false;  \r\n\r\n    },\r\n\r\n    remove: function ( o ) {\r\n\r\n        let i = R.ui.indexOf( o );\r\n        \r\n        if ( i !== -1 ) {\r\n            R.removeListen( o );\r\n            R.ui.splice( i, 1 ); \r\n        }\r\n\r\n        if( R.ui.length === 0 ){\r\n            R.removeEvents();\r\n        }\r\n\r\n    },\r\n\r\n    // ----------------------\r\n    //   EVENTS\r\n    // ----------------------\r\n\r\n    initEvents: function () {\r\n\r\n        if( R.isEventsInit ) return;\r\n\r\n        let dom = document.body;\r\n\r\n        R.isMobile = R.testMobile();\r\n        R.now = R.getTime();\r\n\r\n\r\n        if(!R.isMobile){\r\n            dom.addEventListener( 'wheel', R, { passive: false } );\r\n        } else {\r\n            dom.style.touchAction = 'none';\r\n        }\r\n\r\n        \r\n        dom.addEventListener( 'pointercancel', R );\r\n        dom.addEventListener( 'pointerleave', R );\r\n        //dom.addEventListener( 'pointerout', R )\r\n\r\n        dom.addEventListener( 'pointermove', R );\r\n        dom.addEventListener( 'pointerdown', R );\r\n        dom.addEventListener( 'pointerup', R );\r\n       \r\n\r\n        dom.addEventListener( 'keydown', R, false );\r\n        dom.addEventListener( 'keyup', R, false );\r\n        window.addEventListener( 'resize', R.resize , false );\r\n\r\n        //window.onblur = R.out;\r\n        //window.onfocus = R.in;\r\n\r\n\r\n        R.isEventsInit = true;\r\n        R.dom = dom;\r\n\r\n    },\r\n\r\n    removeEvents: function () {\r\n\r\n        if( !R.isEventsInit ) return;\r\n\r\n        let dom = document.body;\r\n            \r\n        if(!R.isMobile){\r\n            dom.removeEventListener( 'wheel', R );\r\n        }\r\n        \r\n        \r\n        dom.removeEventListener( 'pointercancel', R );\r\n        dom.removeEventListener( 'pointerleave', R );\r\n        //dom.removeEventListener( 'pointerout', R );\r\n\r\n        dom.removeEventListener( 'pointermove', R );\r\n        dom.removeEventListener( 'pointerdown', R );\r\n        dom.removeEventListener( 'pointerup', R );\r\n        \r\n\r\n        dom.removeEventListener( 'keydown', R );\r\n        dom.removeEventListener( 'keyup', R );\r\n        window.removeEventListener( 'resize', R.resize  );\r\n\r\n        R.isEventsInit = false;\r\n\r\n    },\r\n\r\n    resize: function () {\r\n\r\n        R.needReZone = true;\r\n\r\n        let i = R.ui.length, u;\r\n        \r\n        while( i-- ){\r\n\r\n            u = R.ui[i];\r\n            if( u.isGui && !u.isCanvasOnly && u.autoResize ) u.calc();\r\n        \r\n        }\r\n\r\n    },\r\n\r\n    out: function () {\r\n\r\n        console.log('im am out');\r\n        R.clearOldID();\r\n\r\n    },\r\n\r\n    in: function () {\r\n\r\n        console.log('im am in');\r\n      //  R.clearOldID();\r\n\r\n    },\r\n\r\n    // ----------------------\r\n    //   HANDLE EVENTS\r\n    // ----------------------\r\n\r\n    fakeUp: function(){\r\n\r\n        this.handleEvent( {type:'pointerup'} );\r\n\r\n    },\r\n    \r\n\r\n    handleEvent: function ( event ) {\r\n\r\n        //if(!event.type) return;\r\n\r\n        if( R.prevDefault.indexOf( event.type ) !== -1 ) event.preventDefault(); \r\n\r\n        R.findZone();\r\n       \r\n        let e = R.e;\r\n        let leave = false;\r\n        \r\n        if( event.type === 'keydown') R.keydown( event );\r\n        if( event.type === 'keyup') R.keyup( event );\r\n\r\n        if( event.type === 'wheel' ) e.delta = event.deltaY > 0 ? 1 : -1;\r\n        else e.delta = 0;\r\n\r\n        let ptype = event.pointerType; // mouse, pen, touch\r\n\r\n        e.clientX = ( ptype === 'touch' ? event.pageX : event.clientX ) || 0;\r\n        e.clientY = ( ptype === 'touch' ? event.pageY : event.clientY ) || 0;\r\n\r\n        e.type = event.type;\r\n\r\n        if( R.eventOut.indexOf( event.type ) !== -1 ){ \r\n            leave = true;\r\n            e.type = 'mouseup';\r\n        }\r\n\r\n        if( event.type === 'pointerleave'){ R.isLeave = true; }\r\n\r\n        if( event.type === 'pointerdown') e.type = 'mousedown';\r\n        if( event.type === 'pointerup') e.type = 'mouseup';\r\n        if( event.type === 'pointermove'){ \r\n            if( R.isLeave ){ \r\n                // if user resize outside this document\r\n                R.isLeave = false;\r\n                R.resize();\r\n            }\r\n            e.type = 'mousemove';\r\n        }\r\n\r\n        // double click test\r\n        if( e.type === 'mousedown' ) {\r\n            R.downTime = R.now();\r\n            let time = R.downTime - R.prevTime;\r\n\r\n            // double click on imput\r\n            if( time < 200 ) { R.selectAll(); return false }\r\n   \r\n            R.prevTime = R.downTime;\r\n        }\r\n\r\n        // for imput\r\n        if( e.type === 'mousedown' ) R.clearInput();\r\n\r\n        // mouse lock\r\n        if( e.type === 'mousedown' ) R.lock = true;\r\n        if( e.type === 'mouseup' ) R.lock = false;\r\n\r\n        //if( R.current !== null && R.current.neverlock ) R.lock = false;\r\n\r\n        /*if( e.type === 'mousedown' && event.button === 1){\r\n            R.cursor()\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n        }*/\r\n\r\n        if( R.isMobile && e.type === 'mousedown' ) R.findID( e );\r\n        if( e.type === 'mousemove' && !R.lock ) R.findID( e );\r\n        \r\n        if( R.ID !== null ){\r\n\r\n            if( R.ID.isCanvasOnly ) {\r\n\r\n                e.clientX = R.ID.mouse.x;\r\n                e.clientY = R.ID.mouse.y;\r\n\r\n            }\r\n\r\n            R.ID.handleEvent( e );\r\n\r\n        }\r\n\r\n        if( R.isMobile && e.type === 'mouseup' ) R.clearOldID();\r\n        if( leave ) R.clearOldID();\r\n\r\n\r\n    },\r\n\r\n    // ----------------------\r\n    //   ID\r\n    // ----------------------\r\n\r\n    findID: function ( e ) {\r\n\r\n        let i = R.ui.length, next = -1, u, x, y;\r\n\r\n        while( i-- ){\r\n\r\n            u = R.ui[i];\r\n\r\n            if( u.isCanvasOnly ) {\r\n\r\n                x = u.mouse.x;\r\n                y = u.mouse.y;\r\n\r\n            } else {\r\n\r\n                x = e.clientX;\r\n                y = e.clientY;\r\n\r\n            }\r\n\r\n            if( R.onZone( u, x, y ) ){ \r\n                \r\n                next = i;\r\n                \r\n                if( next !== R.current ){\r\n                    R.clearOldID();\r\n                    R.current = next;\r\n                    R.ID = u;\r\n                }\r\n                break;\r\n            }\r\n                \r\n        }\r\n\r\n        if( next === -1 ) R.clearOldID();\r\n\r\n    },\r\n\r\n    clearOldID: function () {\r\n\r\n        if( !R.ID ) return;\r\n        R.current = -1;\r\n        R.ID.reset();\r\n        R.ID = null;\r\n        R.cursor();\r\n\r\n    },\r\n\r\n    // ----------------------\r\n    //   GUI / GROUP FUNCTION\r\n    // ----------------------\r\n\r\n    calcUis: function ( uis, zone, py ) {\r\n\r\n        //console.log('calc_uis')\r\n\r\n        let i = uis.length, u, px = 0, n = 0, tw;\r\n        let height = 0;\r\n        let m = 1;\r\n\r\n        while( i-- ){\r\n\r\n            u = uis[n];\r\n            n++;\r\n\r\n            if( u.isGroup ) u.calcUis();\r\n\r\n            u.zone.w = u.w;\r\n            u.zone.h = u.h;\r\n            m = u.margin;\r\n\r\n            if( !u.autoWidth ){\r\n\r\n                if( px===0 ){ \r\n                    height += u.h + m;\r\n\r\n                } \r\n\r\n                u.zone.x = zone.x + px;\r\n                u.zone.y = py;\r\n\r\n                tw = R.getWidth(u);\r\n                if( tw ) u.zone.w = u.w = tw;\r\n                // focrce width if content is canvas\r\n                else if( u.fw ) u.zone.w = u.w = u.fw;\r\n                \r\n\r\n                //console.log( u.name, u.zone.w, u.w, zone, tw )\r\n                //console.log(  tw )\r\n                px += u.zone.w;\r\n\r\n                if( px >= zone.w ) { \r\n                    py += u.h + m; \r\n                    px = 0; \r\n                }\r\n\r\n            } else {\r\n\r\n                px = 0;\r\n\r\n                u.zone.x = zone.x;\r\n                u.zone.y = py;\r\n                py += u.h + m;\r\n\r\n                height += u.h + m;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return height\r\n\r\n    },\r\n\r\n\r\n\tfindTarget: function ( uis, e ) {\r\n\r\n        let i = uis.length;\r\n\r\n        while( i-- ){\r\n            if( R.onZone( uis[i], e.clientX, e.clientY ) ) return i\r\n        }\r\n\r\n        return -1;\r\n\r\n    },\r\n\r\n    // ----------------------\r\n    //   ZONE\r\n    // ----------------------\r\n\r\n    findZone: function ( force ) {\r\n\r\n        if( !R.needReZone && !force ) return;\r\n\r\n        var i = R.ui.length, u;\r\n\r\n        while( i-- ){ \r\n\r\n            u = R.ui[i];\r\n            R.getZone( u );\r\n            if( u.isGui ) u.calcUis();\r\n\r\n        }\r\n\r\n        R.needReZone = false;\r\n\r\n    },\r\n\r\n    onZone: function ( o, x, y ) {\r\n\r\n        if( x === undefined || y === undefined ) return false;\r\n\r\n        let z = o.zone;\r\n        let mx = x - z.x;\r\n        let my = y - z.y;\r\n\r\n        let over = ( mx >= 0 ) && ( my >= 0 ) && ( mx <= z.w ) && ( my <= z.h );\r\n\r\n        if( over ) o.local.set( mx, my );\r\n        else o.local.neg();\r\n\r\n        return over;\r\n\r\n    },\r\n\r\n    getWidth: function ( o ) {\r\n\r\n\r\n\r\n        //return o.getDom().offsetWidth\r\n        return o.getDom().clientWidth\r\n\r\n        //let r = o.getDom().getBoundingClientRect();\r\n        //return (r.width)\r\n        //return Math.floor(r.width)\r\n\r\n    },\r\n\r\n    getZone: function ( o ) {\r\n\r\n        if( o.isCanvasOnly ) return;\r\n        let r = o.getDom().getBoundingClientRect();\r\n\r\n        //if( !r.width ) return\r\n        //o.zone = { x:Math.floor(r.left), y:Math.floor(r.top), w:Math.floor(r.width), h:Math.floor(r.height) };\r\n        //o.zone = { x:Math.round(r.left), y:Math.round(r.top), w:Math.round(r.width), h:Math.round(r.height) };\r\n        o.zone = { x:r.left, y:r.top, w:r.width, h:r.height };\r\n\r\n        //console.log(o.name, o.zone)\r\n\r\n    },\r\n\r\n    // ----------------------\r\n    //   CURSOR\r\n    // ----------------------\r\n\r\n    cursor: function ( name ) {\r\n\r\n        name = name ? name : 'auto';\r\n        if( name !== R.oldCursor ){\r\n            document.body.style.cursor = name;\r\n            R.oldCursor = name;\r\n        }\r\n\r\n    },\r\n\r\n    // ----------------------\r\n    //   CANVAS\r\n    // ----------------------\r\n\r\n    toCanvas: function ( o, w, h, force ) {\r\n\r\n        if( !R.xmlserializer ) R.xmlserializer = new XMLSerializer();\r\n\r\n        // prevent exesive redraw\r\n\r\n        if( force && R.tmpTime !== null ) { clearTimeout(R.tmpTime); R.tmpTime = null;  }\r\n\r\n        if( R.tmpTime !== null ) return;\r\n\r\n        if( R.lock ) R.tmpTime = setTimeout( function(){ R.tmpTime = null; }, 10 );\r\n\r\n        ///\r\n\r\n        let isNewSize = false;\r\n        if( w !== o.canvas.width || h !== o.canvas.height ) isNewSize = true;\r\n\r\n        if( R.tmpImage === null ) R.tmpImage = new Image();\r\n\r\n        let img = R.tmpImage; //new Image();\r\n\r\n        let htmlString = R.xmlserializer.serializeToString( o.content );\r\n        \r\n        let svg = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"'+w+'\" height=\"'+h+'\"><foreignObject style=\"pointer-events: none; left:0;\" width=\"100%\" height=\"100%\">'+ htmlString +'</foreignObject></svg>';\r\n\r\n        img.onload = function() {\r\n\r\n            let ctx = o.canvas.getContext(\"2d\");\r\n\r\n            if( isNewSize ){ \r\n                o.canvas.width = w;\r\n                o.canvas.height = h;\r\n            }else {\r\n                ctx.clearRect( 0, 0, w, h );\r\n            }\r\n            ctx.drawImage( this, 0, 0 );\r\n\r\n            o.onDraw();\r\n\r\n        };\r\n\r\n        img.src = \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent(svg);\r\n        //img.src = 'data:image/svg+xml;base64,'+ window.btoa( svg );\r\n        img.crossOrigin = '';\r\n\r\n\r\n    },\r\n\r\n    // ----------------------\r\n    //   INPUT\r\n    // ----------------------\r\n\r\n    setHidden: function () {\r\n\r\n\r\n        if( R.hiddenImput === null ){\r\n\r\n            //let css = R.parent.css.txtselect + 'padding:0; width:auto; height:auto; '\r\n            //let css = R.parent.css.txt + 'padding:0; width:auto; height:auto; text-shadow:none;'\r\n            //css += 'left:10px; top:auto; border:none; color:#FFF; background:#000;' + hide;\r\n\r\n            R.hiddenImput = document.createElement('input');\r\n            R.hiddenImput.type = 'text';\r\n            //R.hiddenImput.style.cssText = css + 'bottom:30px;' + (R.debugInput ? '' : 'transform:scale(0);');\r\n\r\n            R.hiddenSizer = document.createElement('div');\r\n            //R.hiddenSizer.style.cssText = css + 'bottom:60px;';\r\n            \r\n            document.body.appendChild( R.hiddenImput );\r\n            document.body.appendChild( R.hiddenSizer );\r\n\r\n        }\r\n\r\n        let hide = R.debugInput ? '' : 'opacity:0; zIndex:0;';\r\n        let css = R.parent.css.txtselect + 'padding:0; width:auto; height:auto; left:10px; top:auto; color:#FFF; background:#000;'+ hide;\r\n        R.hiddenImput.style.cssText = css + 'bottom:10px;' + (R.debugInput ? '' : 'transform:scale(0);');\r\n        R.hiddenSizer.style.cssText = css + 'bottom:40px;';\r\n\r\n        R.hiddenImput.style.width = R.input.clientWidth + 'px';\r\n        R.hiddenImput.value = R.str;\r\n        R.hiddenSizer.innerHTML = R.str;\r\n\r\n        R.hasFocus = true;\r\n\r\n    },\r\n\r\n    clearHidden: function ( p ) {\r\n\r\n        if( R.hiddenImput === null ) return;\r\n        R.hasFocus = false;\r\n\r\n    },\r\n\r\n    clickPos: function( x ){\r\n\r\n        let i = R.str.length, l = 0, n = 0;\r\n        while( i-- ){\r\n            l += R.textWidth( R.str[n] );\r\n            if( l >= x ) break;\r\n            n++;\r\n        }\r\n        return n;\r\n\r\n    },\r\n\r\n    upInput: function ( x, down ) {\r\n\r\n        if( R.parent === null ) return false;\r\n\r\n        let up = false;\r\n     \r\n        if( down ){\r\n\r\n            let id = R.clickPos( x );\r\n\r\n            R.moveX = id;\r\n\r\n            if( R.startX === -1 ){ \r\n\r\n                R.startX = id;\r\n                R.cursorId = id;\r\n                R.inputRange = [ R.startX, R.startX ];\r\n\r\n            } else {\r\n            \r\n                let isSelection = R.moveX !== R.startX;\r\n\r\n                if( isSelection ){\r\n                    if( R.startX > R.moveX ) R.inputRange = [ R.moveX, R.startX ];\r\n                    else R.inputRange = [ R.startX, R.moveX ];    \r\n                }\r\n            }\r\n\r\n            up = true;\r\n            \r\n        } else {\r\n\r\n            if( R.startX !== -1 ){\r\n\r\n                R.hasFocus = true;\r\n                R.hiddenImput.focus();\r\n                R.hiddenImput.selectionStart = R.inputRange[0];\r\n                R.hiddenImput.selectionEnd = R.inputRange[1];\r\n                R.startX = -1;\r\n\r\n                up = true;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        if( up ) R.selectParent();\r\n\r\n        return up;\r\n\r\n    },\r\n\r\n    selectAll: function (){\r\n\r\n        if(!R.parent) return\r\n\r\n        R.str = R.input.textContent;\r\n        R.inputRange = [0, R.str.length ];\r\n        R.hasFocus = true;\r\n        R.hiddenImput.focus();\r\n        R.hiddenImput.selectionStart = R.inputRange[0];\r\n        R.hiddenImput.selectionEnd = R.inputRange[1];\r\n        R.cursorId = R.inputRange[1];\r\n        R.selectParent();\r\n\r\n    },\r\n\r\n    selectParent: function (){\r\n\r\n        var c = R.textWidth( R.str.substring( 0, R.cursorId ));\r\n        var e = R.textWidth( R.str.substring( 0, R.inputRange[0] ));\r\n        var s = R.textWidth( R.str.substring( R.inputRange[0],  R.inputRange[1] ));\r\n\r\n        R.parent.select( c, e, s, R.hiddenSizer.innerHTML );\r\n\r\n    },\r\n\r\n    textWidth: function ( text ){\r\n\r\n        if( R.hiddenSizer === null ) return 0;\r\n        text = text.replace(/ /g, '&nbsp;');\r\n        R.hiddenSizer.innerHTML = text;\r\n        return R.hiddenSizer.clientWidth;\r\n\r\n    },\r\n\r\n\r\n    clearInput: function () {\r\n\r\n        if( R.parent === null ) return;\r\n        if( !R.firstImput ) R.parent.validate( true );\r\n\r\n        R.clearHidden();\r\n        R.parent.unselect();\r\n\r\n        //R.input.style.background = 'none';\r\n        R.input.style.background = R.parent.colors.back;\r\n        R.input.style.borderColor = R.parent.colors.border;\r\n        //R.input.style.color = R.parent.colors.text;\r\n        R.parent.isEdit = false;\r\n\r\n        R.input = null;\r\n        R.parent = null;\r\n        R.str = '',\r\n        R.firstImput = true;\r\n\r\n    },\r\n\r\n    setInput: function ( Input, parent ) {\r\n\r\n        R.clearInput();\r\n        \r\n        R.input = Input;\r\n        R.parent = parent;\r\n\r\n        R.input.style.background = R.parent.colors.backoff;\r\n        R.input.style.borderColor = R.parent.colors.select;\r\n        //R.input.style.color = R.parent.colors.textSelect;\r\n        R.str = R.input.textContent;\r\n\r\n        R.setHidden();\r\n\r\n    },\r\n\r\n    keydown: function ( e ) {\r\n\r\n        if( R.parent === null ) return;\r\n\r\n        let keyCode = e.which; e.shiftKey;\r\n\r\n        //console.log( keyCode )\r\n\r\n        R.firstImput = false;\r\n\r\n\r\n        if (R.hasFocus) {\r\n            // hack to fix touch event bug in iOS Safari\r\n            window.focus();\r\n            R.hiddenImput.focus();\r\n\r\n        }\r\n\r\n\r\n        R.parent.isEdit = true;\r\n\r\n       // e.preventDefault();\r\n\r\n        // add support for Ctrl/Cmd+A selection\r\n        //if ( keyCode === 65 && (e.ctrlKey || e.metaKey )) {\r\n            //R.selectText();\r\n            //e.preventDefault();\r\n            //return self.render();\r\n        //}\r\n\r\n        if( keyCode === 13 ){ //enter\r\n\r\n            R.clearInput();\r\n\r\n        //} else if( keyCode === 9 ){ //tab key\r\n\r\n           // R.input.textContent = '';\r\n\r\n        } else {\r\n\r\n            if( R.input.isNum ){\r\n                if ( ((e.keyCode > 47) && (e.keyCode < 58)) || ((e.keyCode > 95) && (e.keyCode < 106)) || e.keyCode === 190 || e.keyCode === 110 || e.keyCode === 8 || e.keyCode === 109 ){\r\n                    R.hiddenImput.readOnly = false;\r\n                } else {\r\n                    R.hiddenImput.readOnly = true;\r\n                }\r\n            } else {\r\n                R.hiddenImput.readOnly = false;\r\n            }\r\n\r\n        }\r\n\r\n    },\r\n\r\n    keyup: function ( e ) {\r\n\r\n        if( R.parent === null ) return;\r\n\r\n        R.str = R.hiddenImput.value;\r\n\r\n        if( R.parent.allEqual ) R.parent.sameStr( R.str );// numeric samùe value\r\n        else R.input.textContent = R.str;\r\n\r\n        R.cursorId = R.hiddenImput.selectionStart;\r\n        R.inputRange = [ R.hiddenImput.selectionStart, R.hiddenImput.selectionEnd ];\r\n\r\n        R.selectParent();\r\n\r\n        //if( R.parent.allway ) \r\n        R.parent.validate();\r\n\r\n    },\r\n\r\n    // ----------------------\r\n    //\r\n    //   LISTENING\r\n    //\r\n    // ----------------------\r\n\r\n    loop: function () {\r\n\r\n        if( R.isLoop ) requestAnimationFrame( R.loop );\r\n        R.update();\r\n\r\n    },\r\n\r\n    update: function () {\r\n\r\n        let i = R.listens.length;\r\n        while( i-- ) R.listens[i].listening();\r\n\r\n    },\r\n\r\n    removeListen: function ( proto ) {\r\n\r\n        let id = R.listens.indexOf( proto );\r\n        if( id !== -1 ) R.listens.splice(id, 1);\r\n        if( R.listens.length === 0 ) R.isLoop = false;\r\n\r\n    },\r\n\r\n    addListen: function ( proto ) {\r\n\r\n        let id = R.listens.indexOf( proto );\r\n\r\n        if( id !== -1 ) return false; \r\n\r\n        R.listens.push( proto );\r\n\r\n        if( !R.isLoop ){\r\n            R.isLoop = true;\r\n            R.loop();\r\n        }\r\n\r\n        return true;\r\n\r\n    },\r\n\r\n};\r\n\r\nconst Roots = R;\n\n/**\r\n * @author lth / https://github.com/lo-th\r\n */\r\n\r\nconst T = {\r\n\r\n    transition: 0.2,\r\n\r\n    frag: document.createDocumentFragment(),\r\n\r\n    colorRing: null,\r\n    joystick_0: null,\r\n    joystick_1: null,\r\n    circular: null,\r\n    knob: null,\r\n    pad2d: null,\r\n\r\n    svgns: \"http://www.w3.org/2000/svg\",\r\n    links: \"http://www.w3.org/1999/xlink\",\r\n    htmls: \"http://www.w3.org/1999/xhtml\",\r\n\r\n    DOM_SIZE: [ 'height', 'width', 'top', 'left', 'bottom', 'right', 'margin-left', 'margin-right', 'margin-top', 'margin-bottom'],\r\n    SVG_TYPE_D: [ 'pattern', 'defs', 'transform', 'stop', 'animate', 'radialGradient', 'linearGradient', 'animateMotion', 'use', 'filter', 'feColorMatrix' ],\r\n    SVG_TYPE_G: [ 'svg', 'rect', 'circle', 'path', 'polygon', 'text', 'g', 'line', 'foreignObject' ],\r\n\r\n    PI: Math.PI,\r\n    TwoPI: Math.PI*2,\r\n    pi90: Math.PI * 0.5,\r\n    pi60: Math.PI/3,\r\n    \r\n    torad: Math.PI / 180,\r\n    todeg: 180 / Math.PI,\r\n\r\n    clamp: function (v, min, max) {\r\n\r\n        v = v < min ? min : v;\r\n        v = v > max ? max : v;\r\n        return v;\r\n\r\n    },\r\n\r\n    size: {  w: 240, h: 20, p: 30, s: 8 },\r\n\r\n    // ----------------------\r\n    //   COLOR\r\n    // ----------------------\r\n\r\n    defineColor: function( o, cc = T.colors ) {\r\n\r\n        let color = { ...cc };\r\n\r\n        let textChange = ['fontFamily', 'fontWeight', 'fontShadow', 'fontSize' ];\r\n        let changeText = false;\r\n\r\n        if( o.font ) o.fontFamily = o.font;\r\n        if( o.shadow ) o.fontShadow = o.shadow;\r\n        if( o.weight ) o.fontWeight = o.weight;\r\n\r\n        if( o.fontColor ) o.text = o.fontColor;\r\n        if( o.color ) o.text = o.color;\r\n\r\n        if( o.text ){\r\n            color.text = o.text;\r\n            if( !o.fontColor && !o.color ){ \r\n                color.title = T.ColorLuma( o.text, -0.25 );\r\n                color.titleoff = T.ColorLuma( o.text, -0.5 );\r\n            }\r\n            color.textOver = T.ColorLuma( o.text, 0.25 );\r\n            color.textSelect = T.ColorLuma( o.text, 0.5 );\r\n        }\r\n\r\n        if( o.button ){\r\n            color.button = o.button;\r\n            color.border = T.ColorLuma( o.button, 0.1 );\r\n            color.overoff = T.ColorLuma( o.button, 0.2 );\r\n        }\r\n\r\n        if( o.select ){\r\n            color.select = o.select;\r\n            color.over = T.ColorLuma( o.select, -0.1 );\r\n        }\r\n\r\n        if( o.itemBg ) o.back = o.itemBg;\r\n\r\n        if( o.back ){\r\n            color.back = o.back;\r\n            color.backoff = T.ColorLuma( o.back, -0.1 );\r\n        }\r\n\r\n        if( o.fontSelect ) color.textSelect = o.fontSelect;\r\n        if( o.groupBorder ) color.gborder = o.groupBorder;\r\n\r\n        if( o.transparent ) o.bg = 'none';\r\n        if( o.bg ) color.background = color.backgroundOver = o.bg;\r\n        if( o.bgOver ) color.backgroundOver = o.bgOver;\r\n\r\n        for( let m in color ){\r\n            if(o[m]) color[m] = o[m];\r\n        }\r\n\r\n        for( let m in o ){\r\n            if( textChange.indexOf(m) !== -1 ) changeText = true; \r\n        }\r\n\r\n        if( changeText ) T.defineText( color );\r\n\r\n        return color\r\n\r\n    },\r\n\r\n    colors: {\r\n\r\n        content:'none',\r\n        background: 'rgba(50,50,50,0.3)',\r\n        backgroundOver: 'rgba(50,50,50,0.4)',\r\n\r\n        title : '#CCC',\r\n        titleoff : '#BBB',\r\n        text : '#DDD',\r\n        textOver : '#EEE',\r\n        textSelect : '#FFF',\r\n        \r\n        //inputBg: 'rgba(0,0,0,0.25)',\r\n        //itemBg:'rgba(0,0,0,0.25)',\r\n\r\n        back:'rgba(0,0,0,0.2)',\r\n        backoff:'rgba(0,0,0,0.3)',\r\n        //inputOver: 'rgba(0,0,0,0.2)',\r\n\r\n        // input and button border\r\n        border : '#4c4c4c',\r\n        borderSize : 1,\r\n        gborder : 'none',\r\n\r\n        button : '#3c3c3c',\r\n        overoff : '#5c5c5c',\r\n        over : '#024699',\r\n        select : '#308AFF',\r\n        action: '#FF3300',\r\n        \r\n\r\n        //fontFamily: 'Tahoma',\r\n        fontFamily: 'Consolas,monaco,monospace',\r\n        fontWeight: 'normal',\r\n        fontShadow: '#000',\r\n        fontSize:12,\r\n\r\n\r\n        radius:4,\r\n        hide: 'rgba(0,0,0,0)',\r\n\r\n    },\r\n\r\n    // style css\r\n\r\n    css : {\r\n\r\n        //unselect: '-o-user-select:none; -ms-user-select:none; -khtml-user-select:none; -webkit-user-select:none; -moz-user-select:none;', \r\n        basic: 'position:absolute; pointer-events:none; box-sizing:border-box; margin:0; padding:0; overflow:hidden; ' + '-o-user-select:none; -ms-user-select:none; -khtml-user-select:none; -webkit-user-select:none; -moz-user-select:none;',\r\n        button:'display:flex; justify-content:center; align-items:center; text-align:center;',\r\n\r\n        /*txt: T.css.basic + 'font-family:'+ T.colors.fontFamily +'; font-size:'+T.colors.fontSize+'px; color:'+T.colors.text+'; padding:2px 10px; left:0; top:2px; height:16px; width:100px; overflow:hidden; white-space: nowrap;',\r\n        txtselect:  T.css.txt + 'display:flex; justify-content:left; align-items:center; text-align:left;' +'padding:2px 5px; border:1px dashed ' + T.colors.border + '; background:'+ T.colors.txtselectbg+';',\r\n        item: T.css.txt + 'position:relative; background:rgba(0,0,0,0.2); margin-bottom:1px;',*/\r\n    },\r\n\r\n    // svg path\r\n\r\n    svgs: {\r\n\r\n        group:'M 7 7 L 7 8 8 8 8 7 7 7 M 5 7 L 5 8 6 8 6 7 5 7 M 3 7 L 3 8 4 8 4 7 3 7 M 7 5 L 7 6 8 6 8 5 7 5 M 6 6 L 6 5 5 5 5 6 6 6 M 7 3 L 7 4 8 4 8 3 7 3 M 6 4 L 6 3 5 3 5 4 6 4 M 3 5 L 3 6 4 6 4 5 3 5 M 3 3 L 3 4 4 4 4 3 3 3 Z',\r\n        arrow:'M 3 8 L 8 5 3 2 3 8 Z',\r\n        arrowDown:'M 5 8 L 8 3 2 3 5 8 Z',\r\n        arrowUp:'M 5 2 L 2 7 8 7 5 2 Z',\r\n\r\n        solid:'M 13 10 L 13 1 4 1 1 4 1 13 10 13 13 10 M 11 3 L 11 9 9 11 3 11 3 5 5 3 11 3 Z',\r\n        body:'M 13 10 L 13 1 4 1 1 4 1 13 10 13 13 10 M 11 3 L 11 9 9 11 3 11 3 5 5 3 11 3 M 5 4 L 4 5 4 10 9 10 10 9 10 4 5 4 Z',\r\n        vehicle:'M 13 6 L 11 1 3 1 1 6 1 13 3 13 3 11 11 11 11 13 13 13 13 6 M 2.4 6 L 4 2 10 2 11.6 6 2.4 6 M 12 8 L 12 10 10 10 10 8 12 8 M 4 8 L 4 10 2 10 2 8 4 8 Z',\r\n        articulation:'M 13 9 L 12 9 9 2 9 1 5 1 5 2 2 9 1 9 1 13 5 13 5 9 4 9 6 5 8 5 10 9 9 9 9 13 13 13 13 9 Z',\r\n        character:'M 13 4 L 12 3 9 4 5 4 2 3 1 4 5 6 5 8 4 13 6 13 7 9 8 13 10 13 9 8 9 6 13 4 M 6 1 L 6 3 8 3 8 1 6 1 Z',\r\n        terrain:'M 13 8 L 12 7 Q 9.06 -3.67 5.95 4.85 4.04 3.27 2 7 L 1 8 7 13 13 8 M 3 8 Q 3.78 5.420 5.4 6.6 5.20 7.25 5 8 L 7 8 Q 8.39 -0.16 11 8 L 7 11 3 8 Z',\r\n        joint:'M 7.7 7.7 Q 8 7.45 8 7 8 6.6 7.7 6.3 7.45 6 7 6 6.6 6 6.3 6.3 6 6.6 6 7 6 7.45 6.3 7.7 6.6 8 7 8 7.45 8 7.7 7.7 M 3.35 8.65 L 1 11 3 13 5.35 10.65 Q 6.1 11 7 11 8.28 11 9.25 10.25 L 7.8 8.8 Q 7.45 9 7 9 6.15 9 5.55 8.4 5 7.85 5 7 5 6.54 5.15 6.15 L 3.7 4.7 Q 3 5.712 3 7 3 7.9 3.35 8.65 M 10.25 9.25 Q 11 8.28 11 7 11 6.1 10.65 5.35 L 13 3 11 1 8.65 3.35 Q 7.9 3 7 3 5.7 3 4.7 3.7 L 6.15 5.15 Q 6.54 5 7 5 7.85 5 8.4 5.55 9 6.15 9 7 9 7.45 8.8 7.8 L 10.25 9.25 Z',\r\n        ray:'M 9 11 L 5 11 5 12 9 12 9 11 M 12 5 L 11 5 11 9 12 9 12 5 M 11.5 10 Q 10.9 10 10.45 10.45 10 10.9 10 11.5 10 12.2 10.45 12.55 10.9 13 11.5 13 12.2 13 12.55 12.55 13 12.2 13 11.5 13 10.9 12.55 10.45 12.2 10 11.5 10 M 9 10 L 10 9 2 1 1 2 9 10 Z',\r\n        collision:'M 11 12 L 13 10 10 7 13 4 11 2 7.5 5.5 9 7 7.5 8.5 11 12 M 3 2 L 1 4 4 7 1 10 3 12 8 7 3 2 Z',\r\n        map:'M 13 1 L 1 1 1 13 13 13 13 1 M 12 2 L 12 7 7 7 7 12 2 12 2 7 7 7 7 2 12 2 Z',\r\n        material:'M 13 1 L 1 1 1 13 13 13 13 1 M 12 2 L 12 7 7 7 7 12 2 12 2 7 7 7 7 2 12 2 Z',\r\n        texture:'M 13 4 L 13 1 1 1 1 4 5 4 5 13 9 13 9 4 13 4 Z',\r\n        object:'M 10 1 L 7 4 4 1 1 1 1 13 4 13 4 5 7 8 10 5 10 13 13 13 13 1 10 1 Z',\r\n        none:'M 9 5 L 5 5 5 9 9 9 9 5 Z',\r\n        cursor:'M 4 7 L 1 10 1 12 2 13 4 13 7 10 9 14 14 0 0 5 4 7 Z',\r\n\r\n    },\r\n\r\n\r\n    getImput: function(){\r\n\r\n        return Roots.input ? true : false\r\n\r\n    },\r\n\r\n    setStyle : function ( data ){\r\n\r\n        for ( var o in data ){\r\n            if( T.colors[o] ) T.colors[o] = data[o];\r\n        }\r\n\r\n        T.setText();\r\n\r\n    },\r\n\r\n    // ----------------------\r\n    // custom text\r\n    // ----------------------\r\n\r\n    defineText: function( o ){\r\n\r\n        T.setText( o.fontSize, o.text, o.fontFamily, o.fontShadow, o.fontWeight );\r\n\r\n    },\r\n\r\n    setText: function( size, color, font, shadow, weight ){\r\n\r\n        let cc = T.colors;\r\n\r\n        if( font === undefined ) font = cc.fontFamily;\r\n        if( size === undefined ) size = cc.fontSize;\r\n        if( shadow === undefined ) shadow = cc.fontShadow;\r\n        if( weight === undefined ) weight = cc.fontWeight;\r\n        if( color === undefined ) color = cc.text;\r\n        \r\n\r\n        let align = 'display:flex; justify-content:left; align-items:center; text-align:left;';\r\n\r\n        T.css.txt = T.css.basic + align + 'font-family:'+ font +'; font-weight:'+weight+'; font-size:'+size+'px; color:'+cc.text+'; padding:0px 10px; left:0; top:2px; height:16px; width:100px; overflow:hidden; white-space: nowrap;';\r\n        if( shadow !== 'none' ) T.css.txt += ' text-shadow: 1px 1px 1px '+shadow+';';\r\n\r\n        T.css.txtselect = T.css.txt + 'padding:0px 4px; border:1px dashed ' + cc.border + ';';\r\n        //T.css.item = T.css.txt + ' position:relative; margin-bottom:1px; '//display:block; padding:4px 4px;';//\r\n        T.css.item = T.css.txt + ' position:relative; margin-bottom:1px; display:block; padding:2px 4px;';//\r\n\r\n    },\r\n\r\n\r\n    // note\r\n\r\n    //https://developer.mozilla.org/fr/docs/Web/CSS/css_flexible_box_layout/aligning_items_in_a_flex_container\r\n\r\n    /*cloneColor: function () {\r\n\r\n        let cc = Object.assign({}, T.colors );\r\n        return cc;\r\n\r\n    },*/\r\n\r\n    // intern function\r\n\r\n    cloneCss: function () {\r\n\r\n        //let cc = Object.assign({}, T.css );\r\n        return { ...T.css };\r\n\r\n    },\r\n\r\n    clone: function ( o ) {\r\n\r\n        return o.cloneNode( true );\r\n\r\n    },\r\n\r\n    setSvg: function( dom, type, value, id, id2 ){\r\n\r\n        if( id === -1 ) dom.setAttributeNS( null, type, value );\r\n        else if( id2 !== undefined ) dom.childNodes[ id || 0 ].childNodes[ id2 || 0 ].setAttributeNS( null, type, value );\r\n        else dom.childNodes[ id || 0 ].setAttributeNS( null, type, value );\r\n\r\n    },\r\n\r\n    setCss: function( dom, css ){\r\n\r\n        for( let r in css ){\r\n            if( T.DOM_SIZE.indexOf(r) !== -1 ) dom.style[r] = css[r] + 'px';\r\n            else dom.style[r] = css[r];\r\n        }\r\n\r\n    },\r\n\r\n    set: function( g, o ){\r\n\r\n        for( let att in o ){\r\n            if( att === 'txt' ) g.textContent = o[ att ];\r\n            if( att === 'link' ) g.setAttributeNS( T.links, 'xlink:href', o[ att ] );\r\n            else g.setAttributeNS( null, att, o[ att ] );\r\n        }\r\n        \r\n    },\r\n\r\n    get: function( dom, id ){\r\n\r\n        if( id === undefined ) return dom; // root\r\n        else if( !isNaN( id ) ) return dom.childNodes[ id ]; // first child\r\n        else if( id instanceof Array ){\r\n            if(id.length === 2) return dom.childNodes[ id[0] ].childNodes[ id[1] ];\r\n            if(id.length === 3) return dom.childNodes[ id[0] ].childNodes[ id[1] ].childNodes[ id[2] ];\r\n        }\r\n\r\n    },\r\n\r\n    dom : function ( type, css, obj, dom, id ) {\r\n\r\n        type = type || 'div';\r\n\r\n        if( T.SVG_TYPE_D.indexOf(type) !== -1 || T.SVG_TYPE_G.indexOf(type) !== -1 ){ // is svg element\r\n\r\n            if( type ==='svg' ){\r\n\r\n                dom = document.createElementNS( T.svgns, 'svg' );\r\n                T.set( dom, obj );\r\n\r\n          /*  } else if ( type === 'use' ) {\r\n\r\n                dom = document.createElementNS( T.svgns, 'use' );\r\n                T.set( dom, obj );\r\n*/\r\n            } else {\r\n                // create new svg if not def\r\n                if( dom === undefined ) dom = document.createElementNS( T.svgns, 'svg' );\r\n                T.addAttributes( dom, type, obj, id );\r\n\r\n            }\r\n            \r\n        } else { // is html element\r\n\r\n            if( dom === undefined ) dom = document.createElementNS( T.htmls, type );\r\n            else dom = dom.appendChild( document.createElementNS( T.htmls, type ) );\r\n\r\n        }\r\n\r\n        if( css ) dom.style.cssText = css; \r\n\r\n        if( id === undefined ) return dom;\r\n        else return dom.childNodes[ id || 0 ];\r\n\r\n    },\r\n\r\n    addAttributes : function( dom, type, o, id ){\r\n\r\n        let g = document.createElementNS( T.svgns, type );\r\n        T.set( g, o );\r\n        T.get( dom, id ).appendChild( g );\r\n        if( T.SVG_TYPE_G.indexOf(type) !== -1 ) g.style.pointerEvents = 'none';\r\n        return g;\r\n\r\n    },\r\n\r\n    clear : function( dom ){\r\n\r\n        T.purge( dom );\r\n        while (dom.firstChild) {\r\n            if ( dom.firstChild.firstChild ) T.clear( dom.firstChild );\r\n            dom.removeChild( dom.firstChild ); \r\n        }\r\n\r\n    },\r\n\r\n    purge : function ( dom ) {\r\n\r\n        let a = dom.attributes, i, n;\r\n        if (a) {\r\n            i = a.length;\r\n            while(i--){\r\n                n = a[i].name;\r\n                if (typeof dom[n] === 'function') dom[n] = null;\r\n            }\r\n        }\r\n        a = dom.childNodes;\r\n        if (a) {\r\n            i = a.length;\r\n            while(i--){ \r\n                T.purge( dom.childNodes[i] ); \r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    // ----------------------\r\n    //   SVG Effects function\r\n    // ----------------------\r\n\r\n    addSVGGlowEffect: function () {\r\n\r\n        if ( document.getElementById( 'UILGlow') !== null ) return;\r\n\r\n        let svgFilter = T.initUILEffects();\r\n\r\n        let filter = T.addAttributes( svgFilter, 'filter', { id: 'UILGlow', x: '-20%', y: '-20%', width: '140%', height: '140%' } );\r\n        T.addAttributes( filter, 'feGaussianBlur', { in: 'SourceGraphic', stdDeviation: '3', result: 'uilBlur' } );\r\n        let feMerge = T.addAttributes( filter, 'feMerge', {  } );\r\n        \r\n        for( let i = 0; i <= 3; i++ ) {\r\n\r\n            T.addAttributes( feMerge, 'feMergeNode', { in: 'uilBlur' } );\r\n        \r\n        }\r\n\r\n        T.addAttributes( feMerge, 'feMergeNode', { in: 'SourceGraphic' } );\r\n\r\n    },\r\n\r\n    initUILEffects: function () {\r\n\r\n        let svgFilter = document.getElementById( 'UILSVGEffects');\r\n        \r\n        if ( svgFilter === null ) {\r\n            \r\n            svgFilter = T.dom( 'svg', undefined , { id: 'UILSVGEffects', width: '0', height: '0' } );\r\n            document.body.appendChild( svgFilter );\r\n \r\n        }\r\n\r\n        return svgFilter;\r\n\r\n    },\r\n\r\n    // ----------------------\r\n    //   Color function\r\n    // ----------------------\r\n\r\n    ColorLuma : function ( hex, l ) {\r\n\r\n        if( hex === 'n' ) hex = '#000';\r\n\r\n        // validate hex string\r\n        hex = String(hex).replace(/[^0-9a-f]/gi, '');\r\n        if (hex.length < 6) {\r\n            hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];\r\n        }\r\n        l = l || 0;\r\n\r\n        // convert to decimal and change luminosity\r\n        let rgb = \"#\", c, i;\r\n        for (i = 0; i < 3; i++) {\r\n            c = parseInt(hex.substr(i*2,2), 16);\r\n            c = Math.round(Math.min(Math.max(0, c + (c * l)), 255)).toString(16);\r\n            rgb += (\"00\"+c).substr(c.length);\r\n        }\r\n\r\n        return rgb;\r\n\r\n    },\r\n\r\n    findDeepInver: function ( c ) { \r\n\r\n        return (c[0] * 0.3 + c[1] * .59 + c[2] * .11) <= 0.6;\r\n        \r\n    },\r\n\r\n    lerpColor: function( c1, c2, factor ) {\r\n        let newColor = {};\r\n        for ( let i = 0; i < 3; i++ ) {\r\n          newColor[i] = c1[ i ] + ( c2[ i ] - c1[ i ] ) * factor;\r\n        }\r\n        return newColor;\r\n    },\r\n\r\n    hexToHtml: function ( v ) { \r\n        v = v === undefined ? 0x000000 : v;\r\n        return \"#\" + (\"000000\" + v.toString(16)).substr(-6);\r\n        \r\n    },\r\n\r\n    htmlToHex: function ( v ) { \r\n\r\n        return v.toUpperCase().replace(\"#\", \"0x\");\r\n\r\n    },\r\n\r\n    u255: function (c, i) {\r\n\r\n        return parseInt(c.substring(i, i + 2), 16) / 255;\r\n\r\n    },\r\n\r\n    u16: function ( c, i ) {\r\n\r\n        return parseInt(c.substring(i, i + 1), 16) / 15;\r\n\r\n    },\r\n\r\n    unpack: function( c ){\r\n\r\n        if (c.length == 7) return [ T.u255(c, 1), T.u255(c, 3), T.u255(c, 5) ];\r\n        else if (c.length == 4) return [ T.u16(c,1), T.u16(c,2), T.u16(c,3) ];\r\n\r\n    },\r\n\r\n    p255: function ( c ) {\r\n        let h = Math.round( ( c * 255 ) ).toString( 16 );\r\n        if ( h.length < 2 ) h = '0' + h;\r\n        return h;\r\n    },\r\n\r\n    pack: function ( c ) {\r\n\r\n        return '#' + T.p255( c[ 0 ] ) + T.p255( c[ 1 ] ) + T.p255( c[ 2 ] );\r\n\r\n    },\r\n\r\n    htmlRgb: function( c ){\r\n\r\n        return 'rgb(' + Math.round(c[0] * 255) + ','+ Math.round(c[1] * 255) + ','+ Math.round(c[2] * 255) + ')';\r\n\r\n    },\r\n\r\n    pad: function( n ){\r\n        if(n.length == 1)n = '0' + n;\r\n        return n;\r\n    },\r\n\r\n    rgbToHex : function( c ){\r\n\r\n        let r = Math.round(c[0] * 255).toString(16);\r\n        let g = Math.round(c[1] * 255).toString(16);\r\n        let b = Math.round(c[2] * 255).toString(16);\r\n        return '#' + T.pad(r) + T.pad(g) + T.pad(b);\r\n\r\n       // return '#' + ( '000000' + ( ( c[0] * 255 ) << 16 ^ ( c[1] * 255 ) << 8 ^ ( c[2] * 255 ) << 0 ).toString( 16 ) ).slice( - 6 );\r\n\r\n    },\r\n\r\n    hueToRgb: function( p, q, t ){\r\n\r\n        if ( t < 0 ) t += 1;\r\n        if ( t > 1 ) t -= 1;\r\n        if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\r\n        if ( t < 1 / 2 ) return q;\r\n        if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\r\n        return p;\r\n\r\n    },\r\n\r\n    rgbToHsl: function ( c ) {\r\n\r\n        let r = c[0], g = c[1], b = c[2], min = Math.min(r, g, b), max = Math.max(r, g, b), delta = max - min, h = 0, s = 0, l = (min + max) / 2;\r\n        if (l > 0 && l < 1) s = delta / (l < 0.5 ? (2 * l) : (2 - 2 * l));\r\n        if (delta > 0) {\r\n            if (max == r && max != g) h += (g - b) / delta;\r\n            if (max == g && max != b) h += (2 + (b - r) / delta);\r\n            if (max == b && max != r) h += (4 + (r - g) / delta);\r\n            h /= 6;\r\n        }\r\n        return [ h, s, l ];\r\n\r\n    },\r\n\r\n    hslToRgb: function ( c ) {\r\n\r\n        let p, q, h = c[0], s = c[1], l = c[2];\r\n\r\n        if ( s === 0 ) return [ l, l, l ];\r\n        else {\r\n            q = l <= 0.5 ? l * (s + 1) : l + s - ( l * s );\r\n            p = l * 2 - q;\r\n            return [ T.hueToRgb(p, q, h + 0.33333), T.hueToRgb(p, q, h), T.hueToRgb(p, q, h - 0.33333) ];\r\n        }\r\n\r\n    },\r\n\r\n    // ----------------------\r\n    //   SVG MODEL\r\n    // ----------------------\r\n\r\n    makeGradiant: function ( type, settings, parent, colors ) {\r\n\r\n        T.dom( type, null, settings, parent, 0 );\r\n\r\n        let n = parent.childNodes[0].childNodes.length - 1, c;\r\n\r\n        for( let i = 0; i < colors.length; i++ ){\r\n\r\n            c = colors[i];\r\n            //T.dom( 'stop', null, { offset:c[0]+'%', style:'stop-color:'+c[1]+'; stop-opacity:'+c[2]+';' }, parent, [0,n] );\r\n            T.dom( 'stop', null, { offset:c[0]+'%', 'stop-color':c[1],  'stop-opacity':c[2] }, parent, [0,n] );\r\n\r\n        }\r\n\r\n    },\r\n\r\n    /*makeGraph: function () {\r\n\r\n        let w = 128;\r\n        let radius = 34;\r\n        let svg = T.dom( 'svg', T.css.basic , { viewBox:'0 0 '+w+' '+w, width:w, height:w, preserveAspectRatio:'none' } );\r\n        T.dom( 'path', '', { d:'', stroke:T.colors.text, 'stroke-width':4, fill:'none', 'stroke-linecap':'butt' }, svg );//0\r\n        //T.dom( 'rect', '', { x:10, y:10, width:108, height:108, stroke:'rgba(0,0,0,0.3)', 'stroke-width':2 , fill:'none'}, svg );//1\r\n        //T.dom( 'circle', '', { cx:64, cy:64, r:radius, fill:T.colors.button, stroke:'rgba(0,0,0,0.3)', 'stroke-width':8 }, svg );//0\r\n        \r\n        //T.dom( 'circle', '', { cx:64, cy:64, r:radius+7, stroke:'rgba(0,0,0,0.3)', 'stroke-width':7 , fill:'none'}, svg );//2\r\n        //T.dom( 'path', '', { d:'', stroke:'rgba(255,255,255,0.3)', 'stroke-width':2, fill:'none', 'stroke-linecap':'round', 'stroke-opacity':0.5 }, svg );//3\r\n        T.graph = svg;\r\n\r\n    },*/\r\n\r\n    makePad: function ( model ) {\r\n\r\n        let ww = 256;\r\n        let svg = T.dom( 'svg', T.css.basic + 'position:relative;', { viewBox:'0 0 '+ww+' '+ww, width:ww, height:ww, preserveAspectRatio:'none' } );\r\n        let w = 200; \r\n        let d = (ww-w)*0.5, m = 20;\r\n        Tools.dom( 'rect', '', { x: d, y: d,  width: w, height: w, fill:T.colors.back }, svg ); // 0\r\n        Tools.dom( 'rect', '', { x: d+m*0.5, y: d+m*0.5, width: w - m , height: w - m, fill:T.colors.button }, svg ); // 1\r\n        // Pointer\r\n        Tools.dom( 'line', '', { x1: d+(m*0.5), y1: ww *0.5, x2: d+(w-m*0.5), y2: ww * 0.5, stroke:T.colors.back, 'stroke-width': 2 }, svg ); // 2\r\n        Tools.dom( 'line', '', { x1: ww * 0.5, x2: ww * 0.5, y1: d+(m*0.5), y2: d+(w-m*0.5), stroke:T.colors.back, 'stroke-width': 2 }, svg ); // 3\r\n        Tools.dom( 'circle', '', { cx: ww * 0.5, cy: ww * 0.5, r:5, stroke: T.colors.text, 'stroke-width': 5, fill:'none' }, svg ); // 4\r\n        T.pad2d = svg;\r\n\r\n    },\r\n\r\n    makeKnob: function ( model ) {\r\n\r\n        let w = 128;\r\n        let radius = 34;\r\n        let svg = T.dom( 'svg', T.css.basic + 'position:relative;', { viewBox:'0 0 '+w+' '+w, width:w, height:w, preserveAspectRatio:'none' } );\r\n        T.dom( 'circle', '', { cx:64, cy:64, r:radius, fill:T.colors.button, stroke:'rgba(0,0,0,0.3)', 'stroke-width':8 }, svg );//0\r\n        T.dom( 'path', '', { d:'', stroke:T.colors.text, 'stroke-width':4, fill:'none', 'stroke-linecap':'round' }, svg );//1\r\n        T.dom( 'circle', '', { cx:64, cy:64, r:radius+7, stroke:'rgba(0,0,0,0.1)', 'stroke-width':7 , fill:'none'}, svg );//2\r\n        T.dom( 'path', '', { d:'', stroke:'rgba(255,255,255,0.3)', 'stroke-width':2, fill:'none', 'stroke-linecap':'round', 'stroke-opacity':0.5 }, svg );//3\r\n        T.knob = svg;\r\n\r\n    },\r\n\r\n    makeCircular: function ( model ) {\r\n\r\n        let w = 128;\r\n        let radius = 40;\r\n        let svg = T.dom( 'svg', T.css.basic + 'position:relative;', { viewBox:'0 0 '+w+' '+w, width:w, height:w, preserveAspectRatio:'none' } );\r\n        T.dom( 'circle', '', { cx:64, cy:64, r:radius, stroke:'rgba(0,0,0,0.1)', 'stroke-width':10, fill:'none' }, svg );//0\r\n        T.dom( 'path', '', { d:'', stroke:T.colors.text, 'stroke-width':7, fill:'none', 'stroke-linecap':'butt' }, svg );//1\r\n        T.circular = svg;\r\n\r\n    },\r\n\r\n    makeJoystick: function ( model ) {\r\n\r\n        //+' background:#f00;'\r\n\r\n        let w = 128, ccc;\r\n        let radius = Math.floor((w-30)*0.5);\r\n        let innerRadius = Math.floor(radius*0.6);\r\n        let svg = T.dom( 'svg', T.css.basic + 'position:relative;', { viewBox:'0 0 '+w+' '+w, width:w, height:w, preserveAspectRatio:'none' } );\r\n        T.dom( 'defs', null, {}, svg );\r\n        T.dom( 'g', null, {}, svg );\r\n\r\n        if( model === 0 ){\r\n\r\n        \r\n\r\n            // gradian background\r\n            ccc = [ [40, 'rgb(0,0,0)', 0.3], [80, 'rgb(0,0,0)', 0], [90, 'rgb(50,50,50)', 0.4], [100, 'rgb(50,50,50)', 0] ];\r\n            T.makeGradiant( 'radialGradient', { id:'grad', cx:'50%', cy:'50%', r:'50%', fx:'50%', fy:'50%' }, svg, ccc );\r\n\r\n            // gradian shadow\r\n            ccc = [ [60, 'rgb(0,0,0)', 0.5], [100, 'rgb(0,0,0)', 0] ];\r\n            T.makeGradiant( 'radialGradient', { id:'gradS', cx:'50%', cy:'50%', r:'50%', fx:'50%', fy:'50%' }, svg, ccc );\r\n\r\n            // gradian stick\r\n            let cc0 = ['rgb(40,40,40)', 'rgb(48,48,48)', 'rgb(30,30,30)'];\r\n            let cc1 = ['rgb(1,90,197)', 'rgb(3,95,207)', 'rgb(0,65,167)'];\r\n\r\n            ccc = [ [30, cc0[0], 1], [60, cc0[1], 1], [80, cc0[1], 1], [100, cc0[2], 1] ];\r\n            T.makeGradiant( 'radialGradient', { id:'gradIn', cx:'50%', cy:'50%', r:'50%', fx:'50%', fy:'50%' }, svg, ccc );\r\n\r\n            ccc = [ [30, cc1[0], 1], [60, cc1[1], 1], [80, cc1[1], 1], [100, cc1[2], 1] ];\r\n            T.makeGradiant( 'radialGradient', { id:'gradIn2', cx:'50%', cy:'50%', r:'50%', fx:'50%', fy:'50%' }, svg, ccc );\r\n\r\n            // graph\r\n\r\n            T.dom( 'circle', '', { cx:64, cy:64, r:radius, fill:'url(#grad)' }, svg );//2\r\n            T.dom( 'circle', '', { cx:64+5, cy:64+10, r:innerRadius+10, fill:'url(#gradS)' }, svg );//3\r\n            T.dom( 'circle', '', { cx:64, cy:64, r:innerRadius, fill:'url(#gradIn)' }, svg );//4\r\n\r\n            T.joystick_0 = svg;\r\n\r\n        } else {\r\n             // gradian shadow\r\n            ccc = [ [69, 'rgb(0,0,0)', 0],[70, 'rgb(0,0,0)', 0.3], [100, 'rgb(0,0,0)', 0] ];\r\n            T.makeGradiant( 'radialGradient', { id:'gradX', cx:'50%', cy:'50%', r:'50%', fx:'50%', fy:'50%' }, svg, ccc );\r\n\r\n            T.dom( 'circle', '', { cx:64, cy:64, r:radius, fill:'none', stroke:'rgba(100,100,100,0.25)', 'stroke-width':'4' }, svg );//2\r\n            T.dom( 'circle', '', { cx:64, cy:64, r:innerRadius+14, fill:'url(#gradX)' }, svg );//3\r\n            T.dom( 'circle', '', { cx:64, cy:64, r:innerRadius, fill:'none', stroke:'rgb(100,100,100)', 'stroke-width':'4' }, svg );//4\r\n\r\n            T.joystick_1 = svg;\r\n        }\r\n\r\n        \r\n\r\n    },\r\n\r\n    makeColorRing: function () {\r\n\r\n        let w = 256;\r\n        let svg = T.dom( 'svg', T.css.basic + 'position:relative;', { viewBox:'0 0 '+w+' '+w, width:w, height:w, preserveAspectRatio:'none' } );\r\n        T.dom( 'defs', null, {}, svg );\r\n        T.dom( 'g', null, {}, svg );\r\n\r\n        let s = 30;//stroke\r\n        let r =( w-s )*0.5;\r\n        let mid = w*0.5;\r\n        let n = 24, nudge = 8 / r / n * Math.PI, a1 = 0;\r\n        let am, tan, d2, a2, ar, i, j, path, ccc;\r\n        let color = [];\r\n        \r\n        for ( i = 0; i <= n; ++i) {\r\n\r\n            d2 = i / n;\r\n            a2 = d2 * T.TwoPI;\r\n            am = (a1 + a2) * 0.5;\r\n            tan = 1 / Math.cos((a2 - a1) * 0.5);\r\n\r\n            ar = [\r\n                Math.sin(a1), -Math.cos(a1), \r\n                Math.sin(am) * tan, -Math.cos(am) * tan, \r\n                Math.sin(a2), -Math.cos(a2)\r\n            ];\r\n            \r\n            color[1] = T.rgbToHex( T.hslToRgb([d2, 1, 0.5]) );\r\n\r\n            if (i > 0) {\r\n\r\n                j = 6;\r\n                while(j--){\r\n                   ar[j] = ((ar[j]*r)+mid).toFixed(2);\r\n                }\r\n\r\n                path = ' M' + ar[0] + ' ' + ar[1] + ' Q' + ar[2] + ' ' + ar[3] + ' ' + ar[4] + ' ' + ar[5];\r\n\r\n                ccc = [ [0,color[0],1], [100,color[1],1] ];\r\n                T.makeGradiant( 'linearGradient', { id:'G'+i, x1:ar[0], y1:ar[1], x2:ar[4], y2:ar[5], gradientUnits:\"userSpaceOnUse\" }, svg, ccc );\r\n\r\n                T.dom( 'path', '', { d:path, 'stroke-width':s, stroke:'url(#G'+i+')', 'stroke-linecap':\"butt\" }, svg, 1 );\r\n                \r\n            }\r\n            a1 = a2 - nudge; \r\n            color[0] = color[1];\r\n        }\r\n\r\n        let tw = 84.90;\r\n\r\n        // black / white\r\n        ccc = [ [0, '#FFFFFF', 1], [50, '#FFFFFF', 0], [50, '#000000', 0], [100, '#000000', 1] ];\r\n        T.makeGradiant( 'linearGradient', { id:'GL0', x1:0, y1:mid-tw, x2:0, y2:mid+tw, gradientUnits:\"userSpaceOnUse\" }, svg, ccc );\r\n\r\n        ccc = [ [0, '#7f7f7f', 1], [50, '#7f7f7f', 0.5], [100, '#7f7f7f', 0] ];\r\n        T.makeGradiant( 'linearGradient', { id:'GL1', x1:mid-49.05, y1:0, x2:mid+98, y2:0, gradientUnits:\"userSpaceOnUse\" }, svg, ccc );\r\n\r\n        T.dom( 'g', null, { 'transform-origin': '128px 128px', 'transform':'rotate(0)' }, svg );//2\r\n        T.dom( 'polygon', '', { points:'78.95 43.1 78.95 212.85 226 128',  fill:'red'  }, svg, 2 );// 2,0\r\n        T.dom( 'polygon', '', { points:'78.95 43.1 78.95 212.85 226 128',  fill:'url(#GL1)','stroke-width':1, stroke:'url(#GL1)'  }, svg, 2 );//2,1\r\n        T.dom( 'polygon', '', { points:'78.95 43.1 78.95 212.85 226 128',  fill:'url(#GL0)','stroke-width':1, stroke:'url(#GL0)'  }, svg, 2 );//2,2\r\n        T.dom( 'path', '', { d:'M 255.75 136.5 Q 256 132.3 256 128 256 123.7 255.75 119.5 L 241 128 255.75 136.5 Z',  fill:'none','stroke-width':2, stroke:'#000'  }, svg, 2 );//2,3\r\n        //T.dom( 'circle', '', { cx:128+113, cy:128, r:6, 'stroke-width':3, stroke:'#000', fill:'none' }, svg, 2 );//2.3\r\n\r\n        T.dom( 'circle', '', { cx:128, cy:128, r:6, 'stroke-width':2, stroke:'#000', fill:'none' }, svg );//3\r\n\r\n        T.colorRing = svg;\r\n\r\n    },\r\n\r\n    icon: function ( type, color, w ){\r\n\r\n        w = w || 40;\r\n        //color = color || '#DEDEDE';\r\n        let viewBox = '0 0 256 256';\r\n        //let viewBox = '0 0 '+ w +' '+ w;\r\n        let t = [\"<svg xmlns='\"+T.svgns+\"' version='1.1' xmlns:xlink='\"+T.htmls+\"' style='pointer-events:none;' preserveAspectRatio='xMinYMax meet' x='0px' y='0px' width='\"+w+\"px' height='\"+w+\"px' viewBox='\"+viewBox+\"'><g>\"];\r\n        switch(type){\r\n            case 'logo':\r\n            t[1]=\"<path id='logoin' fill='\"+color+\"' stroke='none' d='\"+T.logoFill_d+\"'/>\";\r\n            break;\r\n            case 'donate':\r\n            t[1]=\"<path id='logoin' fill='\"+color+\"' stroke='none' d='\"+T.logo_donate+\"'/>\";\r\n            break;\r\n            case 'neo':\r\n            t[1]=\"<path id='logoin' fill='\"+color+\"' stroke='none' d='\"+T.logo_neo+\"'/>\";\r\n            break;\r\n            case 'github':\r\n            t[1]=\"<path id='logoin' fill='\"+color+\"' stroke='none' d='\"+T.logo_github+\"'/>\";\r\n            break;\r\n            case 'save':\r\n            t[1]=\"<path stroke='\"+color+\"' stroke-width='4' stroke-linejoin='round' stroke-linecap='round' fill='none' d='M 26.125 17 L 20 22.95 14.05 17 M 20 9.95 L 20 22.95'/><path stroke='\"+color;\r\n            t[1]+=\"' stroke-width='2.5' stroke-linejoin='round' stroke-linecap='round' fill='none' d='M 32.6 23 L 32.6 25.5 Q 32.6 28.5 29.6 28.5 L 10.6 28.5 Q 7.6 28.5 7.6 25.5 L 7.6 23'/>\";\r\n            break;\r\n        }\r\n        t[2] = \"</g></svg>\";\r\n        return t.join(\"\\n\");\r\n\r\n    },\r\n\r\n    logoFill_d:`\r\n    M 171 150.75 L 171 33.25 155.5 33.25 155.5 150.75 Q 155.5 162.2 147.45 170.2 139.45 178.25 128 178.25 116.6 178.25 108.55 170.2 100.5 162.2 100.5 150.75 \r\n    L 100.5 33.25 85 33.25 85 150.75 Q 85 168.65 97.55 181.15 110.15 193.75 128 193.75 145.9 193.75 158.4 181.15 171 168.65 171 150.75 \r\n    M 200 33.25 L 184 33.25 184 150.8 Q 184 174.1 167.6 190.4 151.3 206.8 128 206.8 104.75 206.8 88.3 190.4 72 174.1 72 150.8 L 72 33.25 56 33.25 56 150.75 \r\n    Q 56 180.55 77.05 201.6 98.2 222.75 128 222.75 157.8 222.75 178.9 201.6 200 180.55 200 150.75 L 200 33.25 Z\r\n    `,\r\n\r\n    logo_github:`\r\n    M 180.5 70 Q 186.3 82.4 181.55 96.55 196.5 111.5 189.7 140.65 183.65 168.35 146 172.7 152.5 178.7 152.55 185.9 L 152.55 218.15 Q 152.84 224.56 159.15 223.3 \r\n    159.21 223.3 159.25 223.3 181.14 216.25 198.7 198.7 228 169.4 228 128 228 86.6 198.7 57.3 169.4 28 128 28 86.6 28 57.3 57.3 28 86.6 28 128 28 169.4 57.3 198.7 74.85 \r\n    216.25 96.75 223.3 96.78 223.3 96.8 223.3 103.16 224.54 103.45 218.15 L 103.45 200 Q 82.97 203.1 75.1 196.35 69.85 191.65 68.4 185.45 64.27 177.055 59.4 174.15 49.20 \r\n    166.87 60.8 167.8 69.85 169.61 75.7 180 81.13 188.09 90 188.55 98.18 188.86 103.45 185.9 103.49 178.67 110 172.7 72.33 168.33 66.3 140.65 59.48 111.49 74.45 96.55 69.7 \r\n    82.41 75.5 70 84.87 68.74 103.15 80 115.125 76.635 128 76.85 140.85 76.65 152.85 80 171.1 68.75 180.5 70 Z\r\n    `,\r\n\r\n    logo_neo:`\r\n    M 219 52 L 206 52 206 166 Q 206 183.4 193.75 195.65 181.4 208 164 208 146.6 208 134.35 195.65 122 183.4 122 166 L 122 90 Q 122 77.6 113.15 68.85 104.4 60 92 60 79.55 \r\n    60 70.75 68.85 62 77.6 62 90 L 62 204 75 204 75 90 Q 75 83 79.95 78 84.95 73 92 73 99 73 104 78 109 83 109 90 L 109 166 Q 109 188.8 125.15 204.85 141.2 221 164 221 \r\n    186.75 221 202.95 204.85 219 188.8 219 166 L 219 52 M 194 52 L 181 52 181 166 Q 181 173 176.05 178 171.05 183 164 183 157 183 152 178 147 173 147 166 L 147 90 Q 147 \r\n    67.2 130.85 51.15 114.8 35 92 35 69.25 35 53.05 51.15 37 67.2 37 90 L 37 204 50 204 50 90 Q 50 72.6 62.25 60.35 74.6 48 92 48 109.4 48 121.65 60.35 134 72.6 134 90 L \r\n    134 166 Q 134 178.4 142.85 187.15 151.6 196 164 196 176.45 196 185.25 187.15 194 178.4 194 166 L 194 52 Z\r\n    `,\r\n\r\n    logo_donate:`\r\n    M 171.3 80.3 Q 179.5 62.15 171.3 45.8 164.1 32.5 141.35 30.1 L 94.35 30.1 Q 89.35 30.4 88.3 35.15 L 70.5 148.05 Q 70.2 152.5 73.7 152.6 L 100.95 152.6 107 111.6 Q 108.75 \r\n    106.55 112.6 106.45 130.45 108.05 145.3 103.9 163.35 98.75 171.3 80.3 M 179.8 71.5 Q 178.6 79.75 174.9 87.85 168.45 102.9 151.9 109.15 140.65 113.95 117.55 113 113.15 \r\n    112.75 111 117.45 L 102.7 169.95 Q 102.45 173.8 105.5 173.85 L 128.95 173.85 Q 132.2 174.2 133.35 169.65 L 138.3 139.95 Q 139.75 135.6 143.1 135.5 146.6 135.75 150.6 135.65 \r\n    154.55 135.5 157.35 135.1 160.15 134.7 166.75 132.35 181.35 127.4 187.9 111.2 194.25 95.75 189.5 81.95 186.75 74.85 179.8 71.5 M 103.5 209.9 Q 103.5 202.85 99.7 198.85 95.95 \r\n    194.75 89.4 194.75 82.8 194.75 79.05 198.85 75.3 202.9 75.3 209.9 75.3 216.85 79.05 220.95 82.8 225.05 89.4 225.05 95.95 225.05 99.7 221 103.5 216.95 103.5 209.9 M 95.45 205.5 \r\n    Q 95.95 207.3 95.95 209.9 95.95 212.65 95.45 214.35 94.95 216 94 217.3 93.1 218.45 91.9 219 90.7 219.55 89.4 219.55 88.15 219.55 86.95 219.05 85.75 218.55 84.8 217.3 83.9 216.15 \r\n    83.4 214.35 82.85 212.6 82.85 209.9 82.85 207.3 83.4 205.45 83.95 203.55 84.85 202.45 85.9 201.2 86.95 200.75 88.05 200.25 89.4 200.25 90.7 200.25 91.85 200.8 93.05 201.3 94 202.5 \r\n    94.9 203.65 95.45 205.5 M 153.3 195.35 L 145.3 195.35 135.5 224.45 142.8 224.45 144.6 218.5 153.75 218.5 155.6 224.45 163.1 224.45 153.3 195.35 M 152.15 213.25 L 146.25 213.25 \r\n    149.2 203.65 152.15 213.25 M 116.75 195.35 L 107.8 195.35 107.8 224.45 114.5 224.45 114.5 204.2 125.7 224.45 132.75 224.45 132.75 195.35 126.05 195.35 126.05 212.05 116.75 195.35 M \r\n    66.5 197.65 Q 64.15 196.15 61.45 195.75 58.8 195.35 55.75 195.35 L 46.7 195.35 46.7 224.45 55.8 224.45 Q 58.8 224.45 61.5 224.05 64.15 223.6 66.4 222.15 69.15 220.45 70.9 217.2 \r\n    72.7 214 72.7 209.95 72.7 205.7 71 202.6 69.35 199.5 66.5 197.65 M 64.2 205 Q 65.2 207 65.2 209.9 65.2 212.75 64.25 214.75 63.3 216.75 61.5 217.85 60 218.85 58.3 218.9 56.6 219 \r\n    54.15 219 L 54 219 54 200.8 54.15 200.8 Q 56.4 200.8 58.05 200.9 59.7 200.95 61.15 201.75 63.2 202.95 64.2 205 M 210.2 195.35 L 190.5 195.35 190.5 224.45 210.2 224.45 210.2 218.9 \r\n    197.75 218.9 197.75 211.55 209.2 211.55 209.2 206 197.75 206 197.75 200.9 210.2 200.9 210.2 195.35 M 187.5 195.35 L 163 195.35 163 200.9 171.6 200.9 171.6 224.45 178.9 224.45 178.9 \r\n    200.9 187.5 200.9 187.5 195.35 Z\r\n    `,\r\n\r\n};\r\n\r\nT.setText();\r\n\r\nconst Tools = T;\n\n///https://wicg.github.io/file-system-access/#api-filesystemfilehandle-getfile\r\n\r\n\r\nclass Files {\r\n\r\n    //-----------------------------\r\n    //  FILE TYPE\r\n    //-----------------------------\r\n\r\n    static autoTypes( type ) {\r\n\r\n        let t = [];\r\n\r\n        switch( type ){\r\n            case 'svg':\r\n            t = [ { accept: { 'image/svg+xml': '.svg'} }, ];\r\n            break;\r\n            case 'text':\r\n            t = [ { description: 'Text Files', accept: { 'text/plain': ['.txt', '.text'], 'text/html': ['.html', '.htm'] } }, ];\r\n            break;\r\n            case 'json':\r\n            t = [ { description: 'JSON Files', accept: { 'text/plain': ['.json'] } }, ];\r\n            break;\r\n            case 'image':\r\n            t = [ { description: 'Images', accept: { 'image/*': ['.png', '.gif', '.jpeg', '.jpg'] } }, ];\r\n            break;\r\n\r\n        }\r\n\r\n        return t\r\n\r\n    }\r\n\r\n\r\n    //-----------------------------\r\n    //  LOAD\r\n    //-----------------------------\r\n\r\n\tstatic async load( o = {} ) {\r\n\r\n        if (typeof window.showOpenFilePicker !== 'function') {\r\n            window.showOpenFilePicker = this.showOpenFilePickerPolyfill;\r\n        }\r\n\r\n        try {\r\n\r\n        \tlet type = o.type || '';\r\n\r\n            const options = {\r\n                excludeAcceptAllOption: type ? true : false,\r\n                multiple: false,\r\n                //startIn:'./assets'\r\n            };\r\n\r\n            options.types = this.autoTypes( type );\r\n\r\n            // create a new handle\r\n            const handle = await window.showOpenFilePicker( options );\r\n            const file = await handle[0].getFile();\r\n            //let content = await file.text()\r\n\r\n            if( !file ) return null\r\n\r\n            let fname = file.name;\r\n            let ftype = fname.substring( fname.lastIndexOf('.')+1, fname.length );\r\n\r\n            const dataUrl = [ 'png', 'jpg', 'jpeg', 'mp4', 'webm', 'ogg', 'mp3' ];\r\n            const dataBuf = [ 'sea', 'z', 'hex', 'bvh', 'BVH', 'glb', 'gltf' ];\r\n            const reader = new FileReader();\r\n\r\n            if( dataUrl.indexOf( ftype ) !== -1 ) reader.readAsDataURL( file );\r\n            else if( dataBuf.indexOf( ftype ) !== -1 ) reader.readAsArrayBuffer( file );\r\n            else reader.readAsText( file );\r\n\r\n            reader.onload = function(e) {\r\n\r\n                let content = e.target.result;\r\n\r\n                switch(type){\r\n                    case 'image':\r\n                        let img = new Image;\r\n                        img.onload = function() {\r\n                            if( o.callback ) o.callback( img, fname );\r\n                        };\r\n                        img.src = content;\r\n                    break;\r\n                    case 'json':\r\n                        if( o.callback ) o.callback( JSON.parse( content ), fname );\r\n                    break;\r\n                    default:\r\n                        if( o.callback ) o.callback( content, fname );\r\n                    break;\r\n                }\r\n\r\n            };\r\n\r\n        } catch(e) {\r\n\r\n            console.log(e);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\tstatic showOpenFilePickerPolyfill( options ) {\r\n        return new Promise((resolve) => {\r\n            const input = document.createElement(\"input\");\r\n            input.type = \"file\";\r\n            input.multiple = options.multiple;\r\n            input.accept = options.types\r\n                .map((type) => type.accept)\r\n                .flatMap((inst) => Object.keys(inst).flatMap((key) => inst[key]))\r\n                .join(\",\");\r\n\r\n            input.addEventListener(\"change\", () => {\r\n                resolve(\r\n                    [...input.files].map((file) => {\r\n                        return {\r\n                            getFile: async () =>\r\n                                new Promise((resolve) => {\r\n                                    resolve(file);\r\n                                }),\r\n                        };\r\n                    })\r\n                );\r\n            });\r\n\r\n            input.click();\r\n        })\r\n    }\r\n\r\n\r\n    //-----------------------------\r\n    //  SAVE\r\n    //-----------------------------\r\n\r\n    static async save( o = {} ) {\r\n\r\n        this.usePoly = false;\r\n\r\n        if (typeof window.showSaveFilePicker !== 'function') {\r\n            window.showSaveFilePicker = this.showSaveFilePickerPolyfill;\r\n            this.usePoly = true;\r\n        }\r\n\r\n        try {\r\n\r\n            let type = o.type || '';\r\n\r\n            const options = {\r\n                suggestedName: o.name || 'hello',\r\n                data: o.data || ''\r\n            };\r\n\r\n\r\n            options.types = this.autoTypes( type );\r\n            options.finalType = Object.keys(options.types[0].accept )[0];\r\n            options.suggestedName += options.types[0].accept[options.finalType][0];\r\n\r\n\r\n            // create a new handle\r\n            const handle = await window.showSaveFilePicker( options );\r\n\r\n            if( this.usePoly ) return\r\n\r\n            // create a FileSystemWritableFileStream to write to\r\n            const file = await handle.createWritable();\r\n\r\n            let blob = new Blob([ options.data ], { type: options.finalType });\r\n\r\n            // write our file\r\n            await file.write(blob);\r\n\r\n            // close the file and write the contents to disk.\r\n            await file.close();\r\n\r\n        } catch(e) {\r\n\r\n            console.log(e);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    static showSaveFilePickerPolyfill( options ) {\r\n        return new Promise((resolve) => {\r\n            const a = document.createElement(\"a\");\r\n            a.download = options.suggestedName || \"my-file.txt\";\r\n            let blob = new Blob([ options.data ], { type:options.finalType });\r\n            a.href = URL.createObjectURL( blob );\r\n\r\n            a.addEventListener(\"click\", () => {\r\n                resolve(\r\n                    setTimeout( () => URL.revokeObjectURL(a.href), 1000 )\r\n                );\r\n            });\r\n            a.click();\r\n        })\r\n    }\r\n\r\n\r\n    //-----------------------------\r\n    //  FOLDER not possible in poly\r\n    //-----------------------------\r\n\r\n    static async getFolder() {\r\n\r\n        try {\r\n    \r\n            const handle = await window.showDirectoryPicker();\r\n            const files = [];\r\n            for await (const entry of handle.values()) {\r\n                const file = await entry.getFile();\r\n                files.push(file);\r\n            }\r\n\r\n            console.log(files);\r\n            return files;\r\n\r\n        } catch(e) {\r\n\r\n            console.log(e);\r\n\r\n        }\r\n    \r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    \r\n\r\n}\n\nclass V2 {\r\n\r\n\tconstructor( x = 0, y = 0 ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\r\n\t}\r\n\r\n\tset ( x, y ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tdivide ( v ) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmultiply ( v ) {\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmultiplyScalar ( scalar ) {\r\n\r\n\t\tthis.x *= scalar;\r\n\t\tthis.y *= scalar;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tdivideScalar ( scalar ) {\r\n\r\n\t\treturn this.multiplyScalar( 1 / scalar );\r\n\r\n\t}\r\n\r\n\tlength () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\r\n\r\n\t}\r\n\r\n\tangle () {\r\n\r\n\t\t// computes the angle in radians with respect to the positive x-axis\r\n\r\n\t\tvar angle = Math.atan2( this.y, this.x );\r\n\r\n\t\tif ( angle < 0 ) angle += 2 * Math.PI;\r\n\r\n\t\treturn angle;\r\n\r\n\t}\r\n\r\n\taddScalar ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tnegate () {\r\n\r\n\t\tthis.x *= -1;\r\n\t\tthis.y *= -1;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tneg () {\r\n\r\n\t\tthis.x = -1;\r\n\t\tthis.y = -1;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tisZero () {\r\n\r\n\t\treturn ( this.x === 0 && this.y === 0 );\r\n\r\n\t}\r\n\r\n\tcopy ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tequals ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\r\n\r\n\t}\r\n\r\n\tnearEquals ( v, n ) {\r\n\r\n\t\treturn ( ( v.x.toFixed(n) === this.x.toFixed(n) ) && ( v.y.toFixed(n) === this.y.toFixed(n) ) );\r\n\r\n\t}\r\n\r\n\tlerp ( v, alpha ) {\r\n\r\n\t\tif( v === null ){\r\n\t\t\tthis.x -= this.x * alpha;\r\n\t\t    this.y -= this.y * alpha;\r\n\t\t} else {\r\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\t    this.y += ( v.y - this.y ) * alpha;\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}\n\n/**\r\n * @author lth / https://github.com/lo-th\r\n */\r\n\r\nclass Proto {\r\n\r\n    constructor( o = {} ) {\r\n\r\n        \r\n\r\n        // disable mouse controle\r\n        this.lock = o.lock || false;\r\n\r\n        // for button\r\n        this.neverlock = false;\r\n\r\n        // only simple space \r\n        this.isSpace = o.isSpace || false;\r\n\r\n        // if is on gui or group\r\n        this.main = o.main || null;\r\n        this.isUI = o.isUI || false;\r\n        this.group = o.group || null;\r\n\r\n        this.isListen = false;\r\n\r\n        this.isSelectable = o.selectable !== undefined ? o.selectable : false;\r\n        this.unselectable =  o.unselect !== undefined ? o.unselect : this.isSelectable;\r\n\r\n        this.ontop = o.ontop ? o.ontop : false; // 'beforebegin' 'afterbegin' 'beforeend' 'afterend'\r\n\r\n        this.css = this.main ? this.main.css : Tools.css;\r\n\r\n        this.colors = Tools.defineColor( o, this.main ? ( this.group ? this.group.colors : this.main.colors ) : Tools.colors );\r\n\r\n        this.svgs = Tools.svgs;\r\n\r\n        this.zone = { x:0, y:0, w:0, h:0 };\r\n        this.local = new V2().neg();\r\n\r\n        this.isCanvasOnly = false;\r\n        this.isSelect = false;\r\n\r\n        // percent of title\r\n        this.p = o.p !== undefined ? o.p : Tools.size.p;\r\n\r\n        this.w = this.isUI ? this.main.size.w : Tools.size.w;\r\n        if( o.w !== undefined ) this.w = o.w;\r\n\r\n        this.h = this.isUI ? this.main.size.h : Tools.size.h;\r\n        if( o.h !== undefined ) this.h = o.h;\r\n        if( !this.isSpace ) this.h = this.h < 11 ? 11 : this.h;\r\n        else this.lock = true;\r\n\r\n\r\n        // decale for canvas only\r\n        this.fw = o.fw || 0;\r\n\r\n        this.autoWidth = o.auto || true;// auto width or flex \r\n        this.isOpen = false;// open statu\r\n\r\n        // radius for toolbox\r\n        this.radius = o.radius || this.colors.radius;\r\n\r\n        this.transition = o.transition || Tools.transition;\r\n\r\n        // only for number\r\n        this.isNumber = false;\r\n        this.noNeg = o.noNeg || false;\r\n        this.allEqual = o.allEqual || false;\r\n        \r\n        // only most simple \r\n        this.mono = false;\r\n\r\n        // stop listening for edit slide text\r\n        this.isEdit = false;\r\n\r\n        // no title \r\n        this.simple = o.simple || false;\r\n        if( this.simple ) this.sa = 0;\r\n\r\n\r\n        // define obj size\r\n        this.setSize( this.w );\r\n\r\n        // title size\r\n        if( o.sa !== undefined ) this.sa = o.sa;\r\n        if( o.sb !== undefined ) this.sb = o.sb;\r\n        if( this.simple ) this.sb = this.w - this.sa;\r\n\r\n        // last number size for slide\r\n        this.sc = o.sc === undefined ? 47 : o.sc;\r\n\r\n        // for listening object\r\n        this.objectLink = null;\r\n        this.isSend = false;\r\n        this.val = null;\r\n\r\n        this.txt = o.name || '';\r\n        this.name = o.rename || this.txt;\r\n        this.target = o.target || null;\r\n\r\n        // callback\r\n        this.callback = o.callback === undefined ? null : o.callback;\r\n        this.endCallback = null;\r\n        this.openCallback = o.openCallback === undefined ? null : o.openCallback;\r\n        this.closeCallback = o.closeCallback === undefined ? null : o.closeCallback;\r\n\r\n        // if no callback take one from group or gui\r\n        if( this.callback === null && this.isUI && this.main.callback !== null ){ \r\n            this.callback = this.group ? this.group.callback : this.main.callback;\r\n        }\r\n\r\n        // elements\r\n        this.c = [];\r\n\r\n        // style \r\n        this.s = [];\r\n\r\n\r\n        this.useFlex = this.isUI ? this.main.useFlex : false; \r\n        let flexible = this.useFlex ? 'display:flex; justify-content:center; align-items:center; text-align:center; flex: 1 100%;' : 'float:left;';\r\n\r\n        this.c[0] = Tools.dom( 'div', this.css.basic + flexible + 'position:relative; height:20px;');\r\n\r\n\r\n        this.s[0] = this.c[0].style;\r\n\r\n        // bottom margin\r\n        this.margin = o.margin || 1;\r\n        if( this.isUI && this.margin ){ \r\n            this.s[0].boxSizing = 'content-box';\r\n            //this.s[0].marginBottom = this.margin + 'px';\r\n            if( this.margin*0.5===Math.floor(this.margin*0.5) ){\r\n                this.s[0].borderTop = (this.margin*0.5) + 'px solid transparent';\r\n                this.s[0].borderBottom = (this.margin*0.5) + 'px solid transparent';\r\n            } else {\r\n                this.s[0].borderBottom = this.margin + 'px solid transparent';\r\n            }\r\n            \r\n        }\r\n        \r\n        // with title\r\n        if( !this.simple ){ \r\n            this.c[1] = Tools.dom( 'div', this.css.txt );\r\n            this.s[1] = this.c[1].style;\r\n            this.c[1].textContent = this.name;\r\n            this.s[1].color = this.lock ? this.colors.titleoff : this.colors.title;\r\n        }\r\n\r\n        if( o.pos ){\r\n            this.s[0].position = 'absolute';\r\n            for(let p in o.pos){\r\n                this.s[0][p] = o.pos[p];\r\n            }\r\n            this.mono = true;\r\n        }\r\n\r\n\r\n\r\n\r\n        if( o.css ) this.s[0].cssText = o.css; \r\n        \r\n\r\n    }\r\n\r\n    // ----------------------\r\n    // make the node\r\n    // ----------------------\r\n    \r\n    init() {\r\n\r\n        this.zone.h = this.h;\r\n        this.zone.w = this.w;\r\n\r\n        let s = this.s; // style cache\r\n        let c = this.c; // div cach\r\n\r\n        s[0].height = this.h + 'px';\r\n\r\n        if( this.isUI ) s[0].background = this.colors.background;\r\n\r\n        if(!this.autoWidth && this.useFlex ){\r\n            s[0].flex = '1 0 auto';\r\n            s[0].minWidth = this.minw+'px';\r\n            s[0].textAlign = 'center';\r\n        } else {\r\n            if( this.isUI ) s[0].width = '100%';\r\n        }\r\n\r\n        //if( this.autoHeight ) s[0].transition = 'height 0.01s ease-out';\r\n        if( c[1] !== undefined && this.autoWidth ){\r\n            s[1] = c[1].style;\r\n            s[1].height = (this.h-4) + 'px';\r\n            s[1].lineHeight = (this.h-8) + 'px';\r\n        }\r\n\r\n        let frag = Tools.frag;\r\n\r\n        for( let i = 1, lng = c.length; i !== lng; i++ ){\r\n            if( c[i] !== undefined ) {\r\n                frag.appendChild( c[i] );\r\n                s[i] = c[i].style;\r\n            }\r\n        }\r\n\r\n        let pp = this.target !== null ? this.target : ( this.isUI ? this.main.inner : document.body );\r\n\r\n        if( this.ontop ) pp.insertAdjacentElement( 'afterbegin', c[0] );\r\n        else pp.appendChild( c[0] );\r\n\r\n        c[0].appendChild( frag );\r\n\r\n        this.rSize();\r\n\r\n        // ! solo proto\r\n        if( !this.isUI ){\r\n\r\n            this.c[0].style.pointerEvents = 'auto';\r\n            Roots.add( this );\r\n            \r\n        }\r\n\r\n        \r\n        if( this.baseH && this.transition && this.isUI ){\r\n            this.c[0].style.transition = 'height '+this.transition+'s ease-out';\r\n        }\r\n\r\n    }\r\n\r\n    // from Tools\r\n\r\n    dom( type, css, obj, dom, id ) {\r\n\r\n        return Tools.dom( type, css, obj, dom, id );\r\n\r\n    }\r\n\r\n    setSvg( dom, type, value, id, id2 ) {\r\n\r\n        Tools.setSvg( dom, type, value, id, id2 );\r\n\r\n    }\r\n\r\n    setCss( dom, css ) {\r\n\r\n        Tools.setCss( dom, css );\r\n\r\n    }\r\n\r\n    clamp( value, min, max ) {\r\n\r\n        return Tools.clamp( value, min, max );\r\n\r\n    }\r\n\r\n    getColorRing() {\r\n\r\n        if( !Tools.colorRing ) Tools.makeColorRing();\r\n        return Tools.clone( Tools.colorRing );\r\n\r\n    }\r\n\r\n    getJoystick( model ) {\r\n\r\n        if( !Tools[ 'joystick_'+ model ] ) Tools.makeJoystick( model );\r\n        return Tools.clone( Tools[ 'joystick_'+ model ] )\r\n\r\n    }\r\n\r\n    getCircular( model ) {\r\n\r\n        if( !Tools.circular ) Tools.makeCircular( model );\r\n        return Tools.clone( Tools.circular )\r\n\r\n    }\r\n\r\n    getKnob( model ) {\r\n\r\n        if( !Tools.knob ) Tools.makeKnob( model );\r\n        return Tools.clone( Tools.knob )\r\n\r\n    }\r\n\r\n    getPad2d( model ) {\r\n\r\n        if( !Tools.pad2d ) Tools.makePad( model );\r\n        return Tools.clone( Tools.pad2d )\r\n\r\n    }\r\n\r\n    // from Roots\r\n\r\n    cursor( name ) {\r\n\r\n         Roots.cursor( name );\r\n\r\n    }\r\n\r\n    \r\n\r\n    /////////\r\n\r\n    update() {}\r\n\r\n    reset() {}\r\n\r\n    /////////\r\n\r\n    getDom() {\r\n\r\n        return this.c[0]\r\n\r\n    }\r\n\r\n    uiout() {\r\n\r\n        if( this.lock ) return;\r\n\r\n        if(this.s) this.s[0].background = this.colors.background;\r\n\r\n    }\r\n\r\n    uiover() {\r\n\r\n        if( this.lock ) return;\r\n\r\n        if(this.s) this.s[0].background = this.colors.backgroundOver;\r\n\r\n    }\r\n\r\n    rename( s ) {\r\n\r\n        if( this.c[1] !== undefined) this.c[1].textContent = s;\r\n\r\n    }\r\n\r\n    listen() {\r\n\r\n        this.isListen = Roots.addListen( this );\r\n        return this;\r\n\r\n    }\r\n\r\n    listening() {\r\n\r\n        if( this.objectLink === null ) return;\r\n        if( this.isSend ) return;\r\n        if( this.isEdit ) return;\r\n\r\n        this.setValue( this.objectLink[ this.val ] );\r\n\r\n    }\r\n\r\n    setValue( v ) {\r\n\r\n        if( this.isNumber ) this.value = this.numValue( v );\r\n        //else if( v instanceof Array && v.length === 1 ) v = v[0];\r\n        else this.value = v;\r\n        this.update();\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    // update every change\r\n    // ----------------------\r\n\r\n    onChange( f ) {\r\n\r\n        if( this.isSpace ) return\r\n        this.callback = f || null;\r\n        return this\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    // update only on end\r\n    // ----------------------\r\n\r\n    onFinishChange( f ) {\r\n\r\n        if( this.isSpace ) return;\r\n        this.callback = null;\r\n        this.endCallback = f;\r\n        return this\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    // event on open close\r\n    // ----------------------\r\n\r\n    onOpen( f ) {\r\n\r\n        this.openCallback = f;\r\n        return this\r\n\r\n    }\r\n\r\n    onClose( f ) {\r\n\r\n        this.closeCallback = f;\r\n        return this\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //  send back value\r\n    // ----------------------\r\n\r\n    send( v ) {\r\n\r\n        v = v || this.value;\r\n        if( v instanceof Array && v.length === 1 ) v = v[0];\r\n\r\n        this.isSend = true;\r\n        if( this.objectLink !== null ) this.objectLink[ this.val ] = v;\r\n        if( this.callback ) this.callback( v, this.val );\r\n        this.isSend = false;\r\n\r\n    }\r\n\r\n    sendEnd( v ) {\r\n\r\n        v = v || this.value;\r\n        if( v instanceof Array && v.length === 1 ) v = v[0];\r\n\r\n        if( this.endCallback ) this.endCallback( v );\r\n        if( this.objectLink !== null ) this.objectLink[ this.val ] = v;\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    // clear node\r\n    // ----------------------\r\n\r\n    dispose(){\r\n\r\n        if( this.isListen ) Roots.removeListen( this );\r\n\r\n        Tools.clear( this.c[0] );\r\n\r\n        if( this.target !== null ){ \r\n\r\n            if( this.group !== null  ) this.group.clearOne( this );\r\n            else this.target.removeChild( this.c[0] );\r\n\r\n        } else {\r\n\r\n            if( this.isUI ) this.main.clearOne( this );\r\n            else document.body.removeChild( this.c[0] );\r\n\r\n        }\r\n\r\n        if( !this.isUI ) Roots.remove( this );\r\n        \r\n        this.c = null;\r\n        this.s = null;\r\n        this.callback = null;\r\n        this.target = null;\r\n        this.isListen = false;\r\n\r\n    }\r\n    \r\n    clear() {\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    // change size \r\n    // ----------------------\r\n\r\n    getWidth() {\r\n\r\n        let nw = Roots.getWidth( this );\r\n        if(nw) this.w = nw;\r\n\r\n    }\r\n\r\n    setSize( sx ) {\r\n\r\n        if( !this.autoWidth ) return;\r\n        \r\n        this.w = sx;\r\n\r\n        if( this.simple ){\r\n            this.sb = this.w - this.sa;\r\n        } else {\r\n            let pp = this.w * ( this.p / 100 );\r\n            this.sa = Math.floor( pp + 10 );\r\n            this.sb = Math.floor( this.w - pp - 20 );\r\n        }\r\n\r\n    }\r\n\r\n    rSize() {\r\n\r\n        if( !this.autoWidth ) return;\r\n\r\n        if( !this.isUI ) this.s[0].width = this.w + 'px';\r\n        if( !this.simple ) this.s[1].width = this.sa + 'px';\r\n    \r\n    }\r\n\r\n    // ----------------------\r\n    // for numeric value\r\n    // ----------------------\r\n\r\n    setTypeNumber( o ) {\r\n\r\n        this.isNumber = true;\r\n\r\n        this.value = 0;\r\n        if( o.value !== undefined ){\r\n            if( typeof o.value === 'string' ) this.value = o.value * 1;\r\n            else this.value = o.value;\r\n        }\r\n\r\n        this.min = o.min === undefined ? -Infinity : o.min;\r\n        this.max = o.max === undefined ?  Infinity : o.max;\r\n        this.precision = o.precision === undefined ? 2 : o.precision;\r\n\r\n        let s;\r\n\r\n        switch(this.precision){\r\n            case 0: s = 1; break;\r\n            case 1: s = 0.1; break;\r\n            case 2: s = 0.01; break;\r\n            case 3: s = 0.001; break;\r\n            case 4: s = 0.0001; break;\r\n            case 5: s = 0.00001; break;\r\n        }\r\n\r\n        this.step = o.step === undefined ?  s : o.step;\r\n        this.range = this.max - this.min;\r\n        this.value = this.numValue( this.value );\r\n        \r\n    }\r\n\r\n    numValue( n ) {\r\n\r\n        if( this.noNeg ) n = Math.abs( n );\r\n        return Math.min( this.max, Math.max( this.min, n ) ).toFixed( this.precision ) * 1;\r\n\r\n    }\r\n\r\n\r\n    // ----------------------\r\n    //   EVENTS DEFAULT\r\n    // ----------------------\r\n\r\n    handleEvent( e ) {\r\n\r\n        if( this.lock ) return\r\n\r\n        if( this.neverlock ) Roots.lock = false;\r\n\r\n        if( !this[e.type] ) return console.error(e.type, 'this type of event no existe !')\r\n\r\n        return this[e.type](e)\r\n    \r\n    }\r\n\r\n    wheel( e ) { return false; }\r\n    mousedown( e ) { return false; }\r\n    mousemove( e ) { return false; }\r\n    mouseup( e ) { return false; }\r\n    keydown( e ) { return false; }\r\n    keyup( e ) { return false; }\r\n\r\n\r\n    // ----------------------\r\n    // object referency\r\n    // ----------------------\r\n\r\n    setReferency( obj, val ) {\r\n\r\n        this.objectLink = obj;\r\n        this.val = val;\r\n\r\n    }\r\n\r\n    display( v = false ) {\r\n        this.s[0].visibility = v ? 'visible' : 'hidden';\r\n    }\r\n\r\n    // ----------------------\r\n    // resize height \r\n    // ----------------------\r\n\r\n    open () {\r\n\r\n        if( this.isOpen ) return;\r\n        this.isOpen = true;\r\n        if( this.openCallback ) this.openCallback();\r\n\r\n    }\r\n\r\n    close () {\r\n\r\n        if( !this.isOpen ) return\r\n        this.isOpen = false;\r\n        if( this.closeCallback ) this.closeCallback();\r\n\r\n    }\r\n\r\n    needZone() {\r\n\r\n        Roots.needReZone = true;\r\n\r\n    }\r\n\r\n    rezone() {\r\n\r\n        Roots.needReZone = true;\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //  INPUT\r\n    // ----------------------\r\n\r\n    select() {\r\n    \r\n    }\r\n\r\n    unselect() {\r\n\r\n    }\r\n\r\n    setInput( Input ) {\r\n        \r\n        Roots.setInput( Input, this );\r\n\r\n    }\r\n\r\n    upInput( x, down ) {\r\n\r\n        return Roots.upInput( x, down );\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    // special item \r\n    // ----------------------\r\n\r\n    selected( b ){\r\n\r\n        this.isSelect = b || false;\r\n        \r\n    }\r\n\r\n}\n\nclass Bool extends Proto {\r\n\r\n    constructor( o = {} ) {\r\n\r\n        super( o );\r\n        \r\n        this.value = o.value || false;\r\n        this.model = o.mode !== undefined ? o.mode : 0;\r\n\r\n        this.onName = o.rename || this.txt;\r\n        if( o.onName ) o.onname = o.onName;\r\n        if( o.onname ) this.onName = o.onname;\r\n\r\n        this.inh = o.inh || Math.floor( this.h*0.8 );\r\n        this.inw = o.inw || 36;\r\n\r\n        let cc = this.colors;\r\n       \r\n        if( this.model === 0 ){\r\n            let t = Math.floor(this.h*0.5)-((this.inh-2)*0.5);\r\n            this.c[2] = this.dom( 'div', this.css.basic + 'background:'+ cc.inputBg +'; height:'+(this.inh-2)+'px; width:'+this.inw+'px; top:'+t+'px; border-radius:10px; border:2px solid '+ cc.back );\r\n            this.c[3] = this.dom( 'div', this.css.basic + 'height:'+(this.inh-6)+'px; width:16px; top:'+(t+2)+'px; border-radius:10px; background:'+ cc.button+';' );\r\n        } else {\r\n            this.p = 0;\r\n            if( this.c[1] !== undefined ) this.c[1].textContent = '';\r\n            this.c[2] = this.dom( 'div', this.css.txt + this.css.button + 'top:1px; background:'+cc.button+'; height:'+(this.h-2)+'px; border:1px solid '+cc.border+'; border-radius:'+this.radius+'px;' );\r\n        }\r\n\r\n        this.stat = -1;\r\n\r\n        this.init();\r\n        this.update();\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   EVENTS\r\n    // ----------------------\r\n\r\n    mousedown ( e ) {\r\n\r\n        this.value = !this.value;\r\n        this.update( true );\r\n        return this.mousemove( e )\r\n\r\n    }\r\n\r\n    mousemove ( e ) {\r\n\r\n        this.cursor('pointer');\r\n        return this.mode( true )\r\n        \r\n    }\r\n\r\n    reset () {\r\n\r\n        this.cursor();\r\n        return this.mode()\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   MODE\r\n    // ----------------------\r\n\r\n    mode ( over ) {\r\n\r\n        let change = false;\r\n        let cc = this.colors, s, s2, n, v = this.value;\r\n\r\n        if( over ) n = v ? 4 : 3;\r\n        else n = v ? 2 : 1;\r\n\r\n        if( this.stat !== n ){\r\n\r\n            this.stat = n;\r\n\r\n            if( this.model !== 0 ){\r\n\r\n                s = this.s[2];\r\n\r\n                switch( n ){\r\n\r\n                    case 1: s.color = cc.text; s.background = cc.button; break;\r\n                    case 2: s.color = cc.textSelect; s.background = cc.select; break;\r\n                    case 3: s.color = cc.textOver; s.background = cc.overoff; break;\r\n                    case 4: s.color = cc.textOver; s.background = cc.over; break;\r\n\r\n                }\r\n\r\n                this.c[2].innerHTML = v ? this.onName : this.name;\r\n\r\n            } else {\r\n\r\n                s = this.s[2];\r\n                s2 = this.s[3];\r\n\r\n                switch( n ){\r\n\r\n                    case 1: s.background = s.borderColor = cc.back; s2.background = cc.button; break;\r\n                    case 2: s.background = s.borderColor = cc.select; s2.background = cc.button; break;\r\n                    case 3: s.background = s.borderColor = cc.back; s2.background = cc.overoff; break;\r\n                    case 4: s.background = s.borderColor = cc.select; s2.background = cc.over; break;\r\n\r\n                }\r\n\r\n                this.s[3].marginLeft = v ? '17px' : '2px';\r\n                this.c[1].textContent = v ? this.onName : this.name;\r\n\r\n            }\r\n\r\n            change = true;\r\n\r\n        }\r\n\r\n        return change\r\n\r\n    }\r\n\r\n    // ----------------------\r\n\r\n    update ( up ) {\r\n\r\n        this.mode();\r\n        if( up ) this.send();\r\n            \r\n    }\r\n\r\n    rSize () {\r\n\r\n        super.rSize();\r\n\r\n        let s = this.s;\r\n        let w = (this.w - 10 ) - this.inw;\r\n        if( this.model === 0 ){\r\n            s[2].left = w + 'px';\r\n            s[3].left = w + 'px';\r\n        } else {\r\n            s[2].left = this.sa + 'px';\r\n            s[2].width = (this.w- 20)  + 'px';\r\n        }\r\n        \r\n    }\r\n\r\n}\n\nclass Button extends Proto {\r\n\r\n    constructor( o = {} ) {\r\n\r\n        super( o );\r\n\r\n        this.value = o.value || '';\r\n\r\n        this.values = o.value || this.txt;\r\n        if( o.values ) this.values = o.values;\r\n\r\n        \r\n\r\n        this.onName = o.onName || null;\r\n\r\n        this.on = false;\r\n\r\n        // force button width\r\n        this.bw = o.forceWidth || 0;\r\n        if(o.bw) this.bw = o.bw;\r\n        this.space = o.space || 3;\r\n\r\n        if( typeof this.values === 'string' ) this.values = [ this.values ];\r\n\r\n        this.isDown = false;\r\n        this.neverlock = true;\r\n        this.res = 0;\r\n\r\n        this.lng = this.values.length;\r\n        this.tmp = [];\r\n        this.stat = [];\r\n\r\n        let sel, cc = this.colors;\r\n\r\n        for( let i = 0; i < this.lng; i++ ){\r\n\r\n            sel = false;\r\n            if( this.values[i] === this.value && this.isSelectable ) sel = true;\r\n\r\n            this.c[i+2] = this.dom( 'div', this.css.txt + this.css.button + 'top:1px; height:'+(this.h-2)+'px; border:'+cc.borderSize+'px solid '+cc.border+'; border-radius:'+this.radius+'px;' );\r\n            this.c[i+2].style.background = sel ? cc.select : cc.button;\r\n            this.c[i+2].style.color = sel ? cc.textSelect : cc.text;\r\n            this.c[i+2].innerHTML = this.values[i];\r\n            this.stat[i] = sel ? 3:1;\r\n\r\n        }\r\n\r\n        if( !o.value && !o.values ){\r\n            if( this.c[1] !== undefined ) {\r\n                this.c[1].textContent = '';\r\n                this.txt = '';\r\n            }\r\n        } \r\n        if( !this.txt ) this.p = 0; \r\n\r\n        this.init();\r\n\r\n    }\r\n\r\n    onOff() {\r\n\r\n        this.on = !this.on;\r\n        this.label( this.on ? this.onName : this.txt );\r\n        \r\n    }\r\n\r\n    testZone ( e ) {\r\n\r\n        let l = this.local;\r\n        if( l.x === -1 && l.y === -1 ) return -1\r\n\r\n        let i = this.lng;\r\n        let t = this.tmp;\r\n        \r\n        while( i-- ){\r\n        \tif( l.x>t[i][0] && l.x<t[i][2] ) return i\r\n        }\r\n\r\n        return -1\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   EVENTS\r\n    // ----------------------\r\n\r\n    mouseup ( e ) {\r\n\r\n        if( !this.isDown ) return false\r\n\r\n        this.isDown = false;\r\n        if( this.res !== -1 ){\r\n            if( this.value === this.values[this.res] && this.unselectable ) this.value = '';\r\n            else this.value = this.values[this.res];\r\n            if( this.onName !== null ) this.onOff();\r\n            this.send();\r\n        }\r\n\r\n        return this.mousemove( e )\r\n\r\n    }\r\n\r\n    mousedown ( e ) {\r\n\r\n        if( this.isDown ) return false\r\n        this.isDown = true;\r\n    \treturn this.mousemove( e )\r\n\r\n    }\r\n\r\n    mousemove ( e ) {\r\n\r\n        let up = false;\r\n        this.res = this.testZone( e );\r\n\r\n        if( this.res !== -1 ){\r\n            this.cursor('pointer');\r\n            up = this.modes( this.isDown ? 3 : 2, this.res );\r\n        } else {\r\n        \tup = this.reset();\r\n        }\r\n\r\n        return up\r\n\r\n    }\r\n\r\n    // ----------------------\r\n\r\n    modes ( N = 1, id = -1 ) {\r\n\r\n        let i = this.lng, w, n, r = false;\r\n\r\n        while( i-- ){\r\n\r\n            n = N;\r\n            w = this.isSelectable ? this.values[ i ] === this.value : false;\r\n            \r\n            if( i === id ){\r\n                if( w && n === 2 ) n = 3; \r\n            } else {\r\n                n = 1;\r\n                if( w ) n = 4;\r\n            }\r\n\r\n            //if( this.mode( n, i ) ) r = true\r\n            r = this.mode( n, i );\r\n\r\n        }\r\n\r\n        return r\r\n\r\n    }\r\n\r\n    mode ( n, id ) {\r\n\r\n        //if(!this.s) return false\r\n \r\n        let change = false;\r\n        let cc = this.colors, s = this.s;\r\n        let i = id+2;\r\n\r\n        if( this.stat[id] !== n ){\r\n\r\n            this.stat[id] = n;\r\n        \r\n            switch( n ){\r\n\r\n                case 1: s[i].color = cc.text; s[i].background = cc.button; break;\r\n                case 2: s[i].color = cc.textOver; s[i].background = cc.overoff; break;\r\n                case 3: s[i].color = cc.textOver; s[i].background = cc.over; break;\r\n                case 4: s[i].color = cc.textSelect; s[i].background = cc.select; break;\r\n\r\n            }\r\n\r\n            change = true;\r\n\r\n        }\r\n\r\n        return change\r\n\r\n    }\r\n\r\n    // ----------------------\r\n\r\n    reset () {\r\n\r\n        this.res = -1;\r\n        this.cursor();\r\n        return this.modes()\r\n\r\n    }\r\n\r\n    label ( string, n ) {\r\n\r\n        n = n || 2;\r\n        this.c[n].textContent = string;\r\n\r\n    }\r\n\r\n    icon ( string, y = 0, n = 2 ) {\r\n\r\n        //if(y) this.s[n].margin = ( y ) +'px 0px';\r\n        this.s[n].padding = ( y ) +'px 0px';\r\n        this.c[n].innerHTML = string;\r\n\r\n        return this\r\n\r\n    }\r\n\r\n    rSize () {\r\n\r\n        super.rSize();\r\n\r\n        let s = this.s;\r\n        let w = this.sb;\r\n        let d = this.sa;\r\n\r\n        let i = this.lng;\r\n        let dc = this.space;\r\n        let size = Math.floor( ( w-(dc*(i-1)) ) / i );\r\n\r\n        if( this.bw ){ \r\n            size = this.bw < size ? this.bw : size;\r\n            d = Math.floor((this.w-( (size * i) + (dc * (i-1)) ))*0.5);\r\n        }\r\n\r\n        while( i-- ){\r\n\r\n        \tthis.tmp[i] = [ Math.floor( d + ( size * i ) + ( dc * i )), size ];\r\n        \tthis.tmp[i][2] = this.tmp[i][0] + this.tmp[i][1];\r\n\r\n            s[i+2].left = this.tmp[i][0] + 'px';\r\n            s[i+2].width = this.tmp[i][1] + 'px';\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\n\nclass Circular extends Proto {\r\n\r\n    constructor( o = {} ) {\r\n\r\n        super( o );\r\n\r\n        this.isCyclic = o.cyclic || false;\r\n        this.model = o.stype || 0;\r\n        if( o.mode !== undefined ) this.model = o.mode;\r\n\r\n        this.autoWidth = false;\r\n        this.minw = this.w;\r\n        this.diam = o.diam || this.w; \r\n\r\n        this.setTypeNumber( o );\r\n\r\n        this.twoPi = Tools.TwoPI;\r\n        this.pi90 = Tools.pi90;\r\n\r\n        this.offset = new V2();\r\n\r\n        this.h = o.h || this.w + 10;\r\n        this.top = 0;\r\n\r\n        this.c[0].style.width = this.w +'px';\r\n        this.c[0].style.display = 'block';\r\n\r\n        if(this.c[1] !== undefined) {\r\n\r\n            this.c[1].style.width = '100%';\r\n            this.c[1].style.justifyContent = 'center';\r\n            this.top = 10;\r\n            this.h += 10;\r\n\r\n        }\r\n\r\n\r\n\r\n        this.percent = 0;\r\n        this.cmode = 0;\r\n        let cc = this.colors;\r\n\r\n        this.c[2] = this.dom( 'div', this.css.txt + 'justify-content:center; top:'+(this.h-20)+'px; width:100%; color:'+ cc.text );\r\n\r\n        // svg\r\n        \r\n        this.c[3] = this.getCircular();\r\n\r\n        this.setSvg( this.c[3], 'stroke', cc.back, 0 );\r\n        this.setSvg( this.c[3], 'd', this.makePath(), 1 );\r\n        this.setSvg( this.c[3], 'stroke', cc.text, 1 );\r\n\r\n        this.setSvg( this.c[3], 'viewBox', '0 0 '+this.diam+' '+this.diam );\r\n        this.setCss( this.c[3], { width:this.diam, height:this.diam, left:0, top:this.top });\r\n\r\n        this.init();\r\n        this.update();\r\n\r\n    }\r\n\r\n    mode ( mode ) {\r\n\r\n        if( this.cmode === mode ) return false;\r\n\r\n        let cc = this.colors;\r\n        let color;\r\n\r\n        switch( mode ){\r\n            case 0: // base\r\n\r\n                this.s[2].color = cc.text;\r\n                this.setSvg( this.c[3], 'stroke', cc.back, 0);\r\n                color = this.model > 0 ? Tools.pack( Tools.lerpColor( Tools.unpack( Tools.ColorLuma( cc.text, -0.75) ), Tools.unpack( cc.text ), this.percent ) ) : cc.text;\r\n                this.setSvg( this.c[3], 'stroke', color, 1 );\r\n                \r\n            break;\r\n            case 1: // down\r\n\r\n                this.s[2].color = cc.textOver;\r\n                this.setSvg( this.c[3], 'stroke', cc.backoff, 0);\r\n                color = this.model > 0 ? Tools.pack( Tools.lerpColor( Tools.unpack( Tools.ColorLuma( cc.text, -0.75) ), Tools.unpack( cc.text ), this.percent ) ) : cc.textOver;\r\n                this.setSvg( this.c[3], 'stroke', color, 1 );\r\n                \r\n            break;\r\n        }\r\n\r\n        this.cmode = mode;\r\n        return true;\r\n\r\n    }\r\n\r\n    reset () {\r\n\r\n        this.isDown = false;\r\n        \r\n    }\r\n\r\n    testZone ( e ) {\r\n\r\n        let l = this.local;\r\n        if( l.x === -1 && l.y === -1 ) return '';\r\n        \r\n        if( l.y <= this.c[ 1 ].offsetHeight ) return 'title';\r\n        else if ( l.y > this.h - this.c[ 2 ].offsetHeight ) return 'text';\r\n        else return 'circular';\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   EVENTS\r\n    // ----------------------\r\n\r\n    mouseup ( e ) {\r\n\r\n        this.isDown = false;\r\n        this.sendEnd();\r\n        return this.mode(0);\r\n\r\n    }\r\n\r\n    mousedown ( e ) {\r\n\r\n        this.isDown = true;\r\n        this.old = this.value;\r\n        this.oldr = null;\r\n        this.mousemove( e );\r\n        return this.mode(1);\r\n\r\n    }\r\n\r\n    mousemove ( e ) {\r\n\r\n        if( !this.isDown ) return;\r\n\r\n        //console.log('over')\r\n\r\n        let off = this.offset;\r\n        off.x = (this.w*0.5) - ( e.clientX - this.zone.x );\r\n        off.y = (this.diam*0.5) - ( e.clientY - this.zone.y - this.top );\r\n\r\n        this.r = off.angle() - this.pi90;\r\n        this.r = (((this.r%this.twoPi)+this.twoPi)%this.twoPi);\r\n\r\n        if( this.oldr !== null ){ \r\n\r\n            let dif = this.r - this.oldr;\r\n            this.r = Math.abs(dif) > Math.PI ? this.oldr : this.r;\r\n\r\n            if( dif > 6 ) this.r = 0;\r\n            if( dif < -6 ) this.r = this.twoPi;\r\n\r\n        }\r\n\r\n        let steps = 1 / this.twoPi;\r\n        let value = this.r * steps;\r\n\r\n        let n = ( ( this.range * value ) + this.min ) - this.old;\r\n\r\n        if(n >= this.step || n <= this.step){ \r\n            n = ~~ ( n / this.step );\r\n            this.value = this.numValue( this.old + ( n * this.step ) );\r\n            this.update( true );\r\n            this.old = this.value;\r\n            this.oldr = this.r;\r\n        }\r\n\r\n    }\r\n\r\n    wheel ( e ) {\r\n\r\n        let name = this.testZone( e );\r\n\r\n        if( name === 'circular' ) {\r\n    \r\n            let v = this.value - this.step * e.delta;\r\n    \r\n            if ( v > this.max ) {\r\n                v = this.isCyclic ? this.min : this.max;\r\n            } else if ( v < this.min ) {\r\n                v = this.isCyclic ? this.max : this.min;\r\n            }\r\n    \r\n            this.setValue( v );\r\n            this.old = v;\r\n            this.update( true );\r\n\r\n            return true;\r\n    \r\n        }\r\n        return false;\r\n\r\n    }\r\n\r\n    // ----------------------\r\n\r\n    makePath () {\r\n\r\n        let r = 40;\r\n        let d = 24;\r\n        let a = this.percent * this.twoPi - 0.001;\r\n        let x2 = (r + r * Math.sin(a)) + d;\r\n        let y2 = (r - r * Math.cos(a)) + d;\r\n        let big = a > Math.PI ? 1 : 0;\r\n        return \"M \" + (r+d) + \",\" + d + \" A \" + r + \",\" + r + \" 0 \" + big + \" 1 \" + x2 + \",\" + y2;\r\n\r\n    }\r\n\r\n    update ( up ) {\r\n\r\n        this.c[2].textContent = this.value;\r\n        this.percent = ( this.value - this.min ) / this.range;\r\n\r\n        this.setSvg( this.c[3], 'd', this.makePath(), 1 );\r\n\r\n        if ( this.model > 0 ) {\r\n\r\n            let cc = this.colors;\r\n            let color = Tools.pack( Tools.lerpColor( Tools.unpack( Tools.ColorLuma( cc.text, -0.75) ), Tools.unpack( cc.text ), this.percent ) );\r\n            this.setSvg( this.c[3], 'stroke', color, 1 );\r\n        \r\n        }\r\n\r\n        if( up ) this.send();\r\n        \r\n    }\r\n\r\n}\n\nclass Color extends Proto {\r\n\r\n    constructor( o = {} ) {\r\n\r\n        super( o );\r\n\r\n\t    //this.autoHeight = true;\r\n\r\n\t    this.ctype = o.ctype || 'hex';\r\n\r\n\t    this.wfixe = 256;\r\n\r\n\t    this.cw = this.sb > 256 ? 256 : this.sb;\r\n\t    if(o.cw != undefined ) this.cw = o.cw;\r\n\r\n\t    // color up or down\r\n\t    this.side = o.side || 'down';\r\n\t    this.up = this.side === 'down' ? 0 : 1;\r\n\t    \r\n\t    this.baseH = this.h;\r\n\r\n\t    this.offset = new V2();\r\n\t    this.decal = new V2();\r\n\t    this.pp = new V2();\r\n\r\n\t    this.c[2] = this.dom( 'div', this.css.txt + 'height:'+(this.h-4)+'px;' + 'border-radius:'+this.radius+'px; line-height:'+(this.h-8)+'px;' );\r\n\t    this.s[2] = this.c[2].style;\r\n\r\n\t    this.s[2].textShadow = 'none';\r\n\r\n\t    if( this.up ){\r\n\t        this.s[2].top = 'auto';\r\n\t        this.s[2].bottom = '2px';\r\n\t    }\r\n\r\n\t    //this.c[0].style.textAlign = 'center';\r\n\t    this.c[0].style.display = 'block';\r\n\r\n\t    this.c[3] = this.getColorRing();\r\n\t    this.c[3].style.visibility  = 'hidden';\r\n\r\n\t    this.hsl = null;\r\n\t    this.value = '#ffffff';\r\n\t    if( o.value !== undefined ){\r\n\t        if( o.value instanceof Array ) this.value = Tools.rgbToHex( o.value );\r\n\t        else if(!isNaN(o.value)) this.value = Tools.hexToHtml( o.value );\r\n\t        else this.value = o.value;\r\n\t    }\r\n\r\n\t    this.bcolor = null;\r\n\t    this.isDown = false;\r\n\t    this.fistDown = false;\r\n\r\n\t    this.notext = o.notext || false;\r\n\r\n\t    this.tr = 98;\r\n\t    this.tsl = Math.sqrt(3) * this.tr;\r\n\r\n\t    this.hue = 0;\r\n\t    this.d = 256;\r\n\r\n\t    this.setColor( this.value );\r\n\r\n\t    this.init();\r\n\r\n\t    if( o.open !== undefined ) this.open();\r\n\r\n\t}\r\n\r\n\ttestZone ( mx, my ) {\r\n\r\n\t\tlet l = this.local;\r\n\t\tif( l.x === -1 && l.y === -1 ) return '';\r\n\r\n\r\n\r\n\t\tif( this.up && this.isOpen ){\r\n\r\n\t\t\tif( l.y > this.wfixe ) return 'title';\r\n\t\t    else return 'color';\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif( l.y < this.baseH+2 ) return 'title';\r\n\t    \telse if( this.isOpen ) return 'color';\r\n\r\n\r\n\t\t}\r\n\r\n    }\r\n\r\n\t// ----------------------\r\n    //   EVENTS\r\n    // ----------------------\r\n\r\n\tmouseup ( e ) {\r\n\r\n\t    this.isDown = false;\r\n\t    this.d = 256;\r\n\r\n\t}\r\n\r\n\tmousedown ( e ) {\r\n\r\n\r\n\t\tlet name = this.testZone( e.clientX, e.clientY );\r\n\r\n\r\n\t\t//if( !name ) return;\r\n\t\tif(name === 'title'){\r\n\t\t\tif( !this.isOpen ) this.open();\r\n\t        else this.close();\r\n\t        return true;\r\n\t\t}\r\n\r\n\r\n\t\tif( name === 'color' ){\r\n\r\n\t\t\tthis.isDown = true;\r\n\t\t\tthis.fistDown = true;\r\n\t\t\tthis.mousemove( e );\r\n\t\t}\r\n\t}\r\n\r\n\tmousemove ( e ) {\r\n\r\n\t    let name = this.testZone( e.clientX, e.clientY );\r\n\r\n\t    let off, d, hue, sat, lum, rad, x, y, rr, T = Tools;\r\n\r\n\t    if( name === 'title' ) this.cursor('pointer');\r\n\r\n\t    if( name === 'color' ){\r\n\r\n\t    \toff = this.offset;\r\n\t\t    off.x = e.clientX - ( this.zone.x + this.decal.x + this.mid );\r\n\t\t    off.y = e.clientY - ( this.zone.y + this.decal.y + this.mid );\r\n\t\t\td = off.length() * this.ratio;\r\n\t\t\trr = off.angle();\r\n\t\t\tif(rr < 0) rr += 2 * T.PI;\r\n\t\t\t\t\t\t\r\n\r\n\t    \tif ( d < 128 ) this.cursor('crosshair');\r\n\t    \telse if( !this.isDown ) this.cursor();\r\n\r\n\t    \tif( this.isDown ){\r\n\r\n\t\t\t    if( this.fistDown ){\r\n\t\t\t    \tthis.d = d;\r\n\t\t\t    \tthis.fistDown = false;\r\n\t\t\t    }\r\n\r\n\t\t\t    if ( this.d < 128 ) {\r\n\r\n\t\t\t\t    if ( this.d > this.tr ) { // outside hue\r\n\r\n\t\t\t\t        hue = ( rr + T.pi90 ) / T.TwoPI;\r\n\t\t\t\t        this.hue = (hue + 1) % 1;\r\n\t\t\t\t        this.setHSL([(hue + 1) % 1, this.hsl[1], this.hsl[2]]);\r\n\r\n\t\t\t\t    } else { // triangle\r\n\r\n\t\t\t\t    \tx = off.x * this.ratio;\r\n\t\t\t\t    \ty = off.y * this.ratio;\r\n\r\n\t\t\t\t    \tlet rr = (this.hue * T.TwoPI) + T.PI;\r\n\t\t\t\t    \tif(rr < 0) rr += 2 * T.PI;\r\n\r\n\t\t\t\t    \trad = Math.atan2(-y, x);\r\n\t\t\t\t    \tif(rad < 0) rad += 2 * T.PI;\r\n\t\t\t\t\t\t\r\n\t\t\t\t    \tlet rad0 = ( rad + T.pi90 + T.TwoPI + rr ) % (T.TwoPI),\r\n\t\t\t\t    \trad1 = rad0 % ((2/3) * T.PI) - (T.pi60),\r\n\t\t\t\t    \ta    = 0.5 * this.tr,\r\n\t\t\t\t    \tb    = Math.tan(rad1) * a,\r\n\t\t\t\t    \tr    = Math.sqrt(x*x + y*y),\r\n\t\t\t\t    \tmaxR = Math.sqrt(a*a + b*b);\r\n\r\n\t\t\t\t    \tif( r > maxR ) {\r\n\t\t\t\t\t\t\tlet dx = Math.tan(rad1) * r;\r\n\t\t\t\t\t\t\tlet rad2 = Math.atan(dx / maxR);\r\n\t\t\t\t\t\t\tif(rad2 > T.pi60)  rad2 = T.pi60;\r\n\t\t\t\t\t\t    else if( rad2 < -T.pi60 ) rad2 = -T.pi60;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\trad += rad2 - rad1;\r\n\r\n\t\t\t\t\t\t\trad0 = (rad + T.pi90  + T.TwoPI + rr) % (T.TwoPI),\r\n\t\t\t\t\t\t\trad1 = rad0 % ((2/3) * T.PI) - (T.pi60);\r\n\t\t\t\t\t\t\tb = Math.tan(rad1) * a;\r\n\t\t\t\t\t\t\tr = maxR = Math.sqrt(a*a + b*b);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tlum = ((Math.sin(rad0) * r) / this.tsl) + 0.5;\r\n\t\t\t\t\r\n\t\t\t\t\t\tlet w = 1 - (Math.abs(lum - 0.5) * 2);\r\n\t\t\t\t\t\tsat = (((Math.cos(rad0) * r) + (this.tr / 2)) / (1.5 * this.tr)) / w;\r\n\t\t\t\t\t\tsat = T.clamp( sat, 0, 1 );\r\n\t\t\t\t\t\t\r\n\t\t\t\t        this.setHSL([this.hsl[0], sat, lum]);\r\n\r\n\t\t\t\t    }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// ----------------------\r\n\r\n\tsetHeight () {\r\n\r\n\t\tthis.h = this.isOpen ? this.wfixe + this.baseH + 5 : this.baseH;\r\n\t\tthis.s[0].height = this.h + 'px';\r\n\t\tthis.zone.h = this.h;\r\n\r\n\t}\r\n\r\n\tparentHeight ( t ) {\r\n\r\n\t\tif ( this.group !== null ) this.group.calc( t );\r\n\t    else if ( this.isUI ) this.main.calc( t );\r\n\r\n\t}\r\n\r\n\topen () {\r\n\r\n\t\tsuper.open();\r\n\r\n\t\tthis.setHeight();\r\n\r\n\t\tif( this.up ) this.zone.y -= this.wfixe + 5;\r\n\r\n\t\tlet t = this.h - this.baseH;\r\n\r\n\t    this.s[3].visibility = 'visible';\r\n\t    //this.s[3].display = 'block';\r\n\t    this.parentHeight( t );\r\n\r\n\t}\r\n\r\n\tclose () {\r\n\r\n\t\tsuper.close();\r\n\r\n\t\tif( this.up ) this.zone.y += this.wfixe + 5;\r\n\r\n\t\tlet t = this.h - this.baseH;\r\n\r\n\t\tthis.setHeight();\r\n\r\n\t    this.s[3].visibility  = 'hidden';\r\n\t    //this.s[3].display = 'none';\r\n\t    this.parentHeight( -t );\r\n\r\n\t}\r\n\r\n\tupdate ( up ) {\r\n\r\n\t    let cc = Tools.rgbToHex( Tools.hslToRgb([ this.hsl[0], 1, 0.5 ]) );\r\n\r\n\t    this.moveMarkers();\r\n\t    \r\n\t    this.value = this.bcolor;\r\n\r\n\t    this.setSvg( this.c[3], 'fill', cc, 2, 0 );\r\n\r\n\r\n\t    this.s[2].background = this.bcolor;\r\n\t    if(!this.notext) this.c[2].textContent = Tools.htmlToHex( this.bcolor );\r\n\r\n\t    this.invert = Tools.findDeepInver( this.rgb );\r\n\t    this.s[2].color = this.invert ? '#fff' : '#000';\r\n\r\n\t    if(!up) return;\r\n\r\n\t    if( this.ctype === 'array' ) this.send( this.rgb );\r\n\t    if( this.ctype === 'rgb' ) this.send( Tools.htmlRgb( this.rgb ) );\r\n\t    if( this.ctype === 'hex' ) this.send( Tools.htmlToHex( this.value ) );\r\n\t    if( this.ctype === 'html' ) this.send();\r\n\r\n\t}\r\n\r\n\tsetValue ( v ){\r\n\r\n\t\tif( v instanceof Array ) this.value = Tools.rgbToHex( v );\r\n        else if(!isNaN(v)) this.value = Tools.hexToHtml( v );\r\n        else this.value = v;\r\n\r\n\t\tthis.setColor( this.value );\r\n        this.update();\r\n\r\n\t}\r\n\r\n\tsetColor ( color ) {\r\n\r\n\t    let unpack = Tools.unpack(color);\r\n\t    if (this.bcolor !== color && unpack) {\r\n\r\n\t        this.bcolor = color;\r\n\t        this.rgb = unpack;\r\n\t        this.hsl = Tools.rgbToHsl( this.rgb );\r\n\r\n\t        this.hue = this.hsl[0];\r\n\r\n\t        this.update();\r\n\t    }\r\n\t    return this;\r\n\r\n\t}\r\n\r\n\tsetHSL ( hsl ) {\r\n\r\n\t    this.hsl = hsl;\r\n\t    this.rgb = Tools.hslToRgb( hsl );\r\n\t    this.bcolor = Tools.rgbToHex( this.rgb );\r\n\t    this.update( true );\r\n\t    return this;\r\n\r\n\t}\r\n\r\n\tmoveMarkers () {\r\n\r\n\t\tlet p = this.pp;\r\n\t\tlet T = Tools;\r\n\r\n\t    this.invert ? '#fff' : '#000';\r\n\t    let a = this.hsl[0] * T.TwoPI;\r\n\t    let third = (2/3) * T.PI;\r\n\t    let r = this.tr;\r\n\t    let h = this.hsl[0];\r\n\t    let s = this.hsl[1];\r\n\t    let l = this.hsl[2];\r\n\r\n\t    let angle = ( a - T.pi90 ) * T.todeg;\r\n\r\n\t    h = - a + T.pi90;\r\n\r\n\t\tlet hx = Math.cos(h) * r;\r\n\t\tlet hy = -Math.sin(h) * r;\r\n\t\tlet sx = Math.cos(h - third) * r;\r\n\t\tlet sy = -Math.sin(h - third) * r;\r\n\t\tlet vx = Math.cos(h + third) * r;\r\n\t\tlet vy = -Math.sin(h + third) * r;\r\n\t\tlet mx = (sx + vx) / 2, my = (sy + vy) / 2;\r\n\t\ta  = (1 - 2 * Math.abs(l - .5)) * s;\r\n\t\tlet x = sx + (vx - sx) * l + (hx - mx) * a;\r\n\t\tlet y = sy + (vy - sy) * l + (hy - my) * a;\r\n\r\n\t    p.set( x, y ).addScalar(128);\r\n\r\n\t    //let ff = (1-l)*255;\r\n\t    // this.setSvg( this.c[3], 'stroke', 'rgb('+ff+','+ff+','+ff+')', 3 );\r\n\r\n\t    this.setSvg( this.c[3], 'transform', 'rotate('+angle+' )', 2 );\r\n\r\n\t    this.setSvg( this.c[3], 'cx', p.x, 3 );\r\n\t    this.setSvg( this.c[3], 'cy', p.y, 3 );\r\n\t    \r\n\t    this.setSvg( this.c[3], 'stroke', this.invert ? '#fff' : '#000', 2, 3 );\r\n\t    this.setSvg( this.c[3], 'stroke', this.invert ? '#fff' : '#000', 3 );\r\n\t    this.setSvg( this.c[3], 'fill',this.bcolor, 3 );\r\n\r\n\t}\r\n\r\n\trSize () {\r\n\r\n\t    //Proto.prototype.rSize.call( this );\r\n\t    super.rSize();\r\n\r\n\t    let s = this.s;\r\n\r\n\t    s[2].width = this.sb + 'px';\r\n\t    s[2].left = this.sa + 'px';\r\n\r\n\t    this.rSizeColor( this.cw );\r\n\r\n\t    this.decal.x = Math.floor((this.w - this.wfixe) * 0.5);\r\n\t    //s[3].left = this.decal.x + 'px';\r\n\t    \r\n\t}\r\n\r\n\trSizeColor ( w ) {\r\n\r\n\t\tif( w === this.wfixe ) return;\r\n\r\n\t\tthis.wfixe = w;\r\n\r\n\t\tlet s = this.s;\r\n\r\n\t\t//this.decal.x = Math.floor((this.w - this.wfixe) * 0.5);\r\n\t    this.decal.y = this.side === 'up' ? 2 : this.baseH + 2;\r\n\t    this.mid = Math.floor( this.wfixe * 0.5 );\r\n\r\n\t    this.setSvg( this.c[3], 'viewBox', '0 0 '+ this.wfixe + ' '+ this.wfixe );\r\n\t    s[3].width = this.wfixe + 'px';\r\n\t    s[3].height = this.wfixe + 'px';\r\n    \t//s[3].left = this.decal.x + 'px';\r\n\t    s[3].top = this.decal.y + 'px';\r\n\r\n\t    this.ratio = 256 / this.wfixe;\r\n\t    this.square = 1 / (60*(this.wfixe/256));\r\n\t    this.setHeight();\r\n\r\n\t}\r\n\r\n\r\n}\n\nclass Fps extends Proto {\r\n\r\n    constructor( o = {} ) {\r\n\r\n        super( o );\r\n\r\n        this.round = Math.round;\r\n\r\n        //this.autoHeight = true;\r\n\r\n        this.baseH = this.h;\r\n        this.hplus = o.hplus || 50;\r\n\r\n        this.res = o.res || 40;\r\n        this.l = 1;\r\n\r\n        this.precision = o.precision || 0;\r\n        \r\n\r\n        this.custom = o.custom || false;\r\n        this.names = o.names || ['FPS', 'MS'];\r\n        let cc = o.cc || ['220,220,220', '255,255,0'];\r\n\r\n       // this.divid = [ 100, 100, 100 ];\r\n       // this.multy = [ 30, 30, 30 ];\r\n\r\n        this.adding = o.adding || false;\r\n\r\n        this.range = o.range || [ 165, 100, 100 ];\r\n\r\n        this.alpha = o.alpha || 0.25;\r\n\r\n        this.values = [];\r\n        this.points = [];\r\n        this.textDisplay = [];\r\n\r\n        if(!this.custom){\r\n\r\n            this.now = Roots.getTime();\r\n            this.startTime = 0;//this.now()\r\n            this.prevTime = 0;//this.startTime;\r\n            this.frames = 0;\r\n\r\n            this.ms = 0;\r\n            this.fps = 0;\r\n            this.mem = 0;\r\n            this.mm = 0;\r\n\r\n            this.isMem = ( self.performance && self.performance.memory ) ? true : false;\r\n\r\n           // this.divid = [ 100, 200, 1 ];\r\n           // this.multy = [ 30, 30, 30 ];\r\n\r\n            if( this.isMem ){\r\n\r\n                this.names.push('MEM');\r\n                cc.push('0,255,255');\r\n\r\n            }\r\n\r\n            this.txt = o.name || 'Fps';\r\n\r\n        }\r\n\r\n\r\n        let fltop = Math.floor(this.h*0.5)-6;\r\n\r\n        this.c[1].textContent = this.txt;\r\n        this.c[0].style.cursor = 'pointer';\r\n        this.c[0].style.pointerEvents = 'auto';\r\n\r\n        let panelCss = 'display:none; left:10px; top:'+ this.h + 'px; height:'+(this.hplus - 8)+'px; box-sizing:border-box; background: rgba(0, 0, 0, 0.2); border:1px solid '+ this.colors.border +';';\r\n\r\n        if( this.radius !== 0 ) panelCss += 'border-radius:' + this.radius+'px;'; \r\n\r\n        this.c[2] = this.dom( 'path', this.css.basic + panelCss , {} );\r\n\r\n        this.c[2].setAttribute('viewBox', '0 0 '+this.res+' 50' );\r\n        this.c[2].setAttribute('height', '100%' );\r\n        this.c[2].setAttribute('width', '100%' );\r\n        this.c[2].setAttribute('preserveAspectRatio', 'none' );\r\n\r\n\r\n        //this.dom( 'path', null, { fill:'rgba(255,255,0,0.3)', 'stroke-width':1, stroke:'#FF0', 'vector-effect':'non-scaling-stroke' }, this.c[2] );\r\n        //this.dom( 'path', null, { fill:'rgba(0,255,255,0.3)', 'stroke-width':1, stroke:'#0FF', 'vector-effect':'non-scaling-stroke' }, this.c[2] );\r\n        \r\n        // arrow\r\n        this.c[3] = this.dom( 'path', this.css.basic + 'position:absolute; width:10px; height:10px; left:4px; top:'+fltop+'px;', { d:this.svgs.arrow, fill:this.colors.text, stroke:'none'});\r\n\r\n        // result test\r\n        this.c[4] = this.dom( 'div', this.css.txt + 'position:absolute; left:10px; top:'+(this.h+2) +'px; display:none; width:100%; text-align:center;' );\r\n\r\n        // bottom line\r\n        if( o.bottomLine ) this.c[4] = this.dom( 'div', this.css.basic + 'width:100%; bottom:0px; height:1px; background: rgba(255, 255, 255, 0.2);');\r\n\r\n        this.isShow = false;\r\n\r\n        let s = this.s;\r\n\r\n        s[1].marginLeft = '10px';\r\n        s[1].lineHeight = this.h-4;\r\n        s[1].color = this.colors.text;\r\n        s[1].fontWeight = 'bold';\r\n\r\n        if( this.radius !== 0 )  s[0].borderRadius = this.radius+'px';\r\n        if( this.colors.gborder!=='none') s[0].border = '1px solid ' + this.colors.gborder;\r\n\r\n\r\n\r\n\r\n        let j = 0;\r\n\r\n        for( j=0; j<this.names.length; j++ ){\r\n\r\n            let base = [];\r\n            let i = this.res+1;\r\n            while( i-- ) base.push(50);\r\n\r\n            this.range[j] = ( 1 / this.range[j] ) * 49;\r\n            \r\n            this.points.push( base );\r\n            this.values.push(0);\r\n           //  this.dom( 'path', null, { fill:'rgba('+cc[j]+',0.5)', 'stroke-width':1, stroke:'rgba('+cc[j]+',1)', 'vector-effect':'non-scaling-stroke' }, this.c[2] );\r\n            this.textDisplay.push( \"<span style='color:rgb(\"+cc[j]+\")'> \" + this.names[j] +\" \");\r\n\r\n        }\r\n\r\n        j = this.names.length;\r\n        while(j--){\r\n            this.dom( 'path', null, { fill:'rgba('+cc[j]+','+this.alpha+')', 'stroke-width':1, stroke:'rgba('+cc[j]+',1)', 'vector-effect':'non-scaling-stroke' }, this.c[2] );\r\n        }\r\n\r\n\r\n        this.init();\r\n\r\n        //if( this.isShow ) this.show();\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   EVENTS\r\n    // ----------------------\r\n\r\n    mousedown ( e ) {\r\n\r\n        if( this.isShow ) this.close();\r\n        else this.open();\r\n\r\n    }\r\n\r\n    // ----------------------\r\n\r\n    /*mode: function ( mode ) {\r\n\r\n        let s = this.s;\r\n\r\n        switch(mode){\r\n            case 0: // base\r\n                s[1].color = this.colors.text;\r\n                //s[1].background = 'none';\r\n            break;\r\n            case 1: // over\r\n                s[1].color = '#FFF';\r\n                //s[1].background = UIL.SELECT;\r\n            break;\r\n            case 2: // edit / down\r\n                s[1].color = this.colors.text;\r\n                //s[1].background = UIL.SELECTDOWN;\r\n            break;\r\n\r\n        }\r\n    },*/\r\n\r\n    tick ( v ) {\r\n\r\n        this.values = v;\r\n        if( !this.isShow ) return;\r\n        this.drawGraph();\r\n        this.upText();\r\n\r\n    }\r\n\r\n    makePath ( point ) {\r\n\r\n        let p = '';\r\n        p += 'M ' + (-1) + ' ' + 50;\r\n        for ( let i = 0; i < this.res + 1; i ++ ) { p += ' L ' + i + ' ' + point[i]; }\r\n        p += ' L ' + (this.res + 1) + ' ' + 50;\r\n        return p;\r\n\r\n    }\r\n\r\n    upText ( val ) {\r\n\r\n        let v = val || this.values, t = '';\r\n        for( let j=0, lng =this.names.length; j<lng; j++ ) t += this.textDisplay[j] + (v[j]).toFixed(this.precision) + '</span>';\r\n        this.c[4].innerHTML = t;\r\n    \r\n    }\r\n\r\n    drawGraph () {\r\n\r\n        let svg = this.c[2];\r\n        let i = this.names.length, v, old = 0, n = 0;\r\n\r\n        while( i-- ){\r\n            if( this.adding ) v = (this.values[n]+old) * this.range[n];\r\n            else  v = (this.values[n] * this.range[n]);\r\n            this.points[n].shift();\r\n            this.points[n].push( 50 - v );\r\n            this.setSvg( svg, 'd', this.makePath( this.points[n] ), i+1 );\r\n            old += this.values[n];\r\n            n++;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    open () {\r\n\r\n        super.open();\r\n\r\n        this.h = this.hplus + this.baseH;\r\n\r\n        this.setSvg( this.c[3], 'd', this.svgs.arrowDown );\r\n\r\n        if( this.group !== null ){ this.group.calc( this.hplus );}\r\n        else if( this.isUI ) this.main.calc( this.hplus );\r\n\r\n        this.s[0].height = this.h +'px';\r\n        this.s[2].display = 'block'; \r\n        this.s[4].display = 'block';\r\n        this.isShow = true;\r\n\r\n        if( !this.custom ) Roots.addListen( this );\r\n\r\n    }\r\n\r\n    close () {\r\n\r\n        super.close();\r\n\r\n        this.h = this.baseH;\r\n\r\n        this.setSvg( this.c[3], 'd', this.svgs.arrow );\r\n\r\n        if( this.group !== null ){ this.group.calc( -this.hplus );}\r\n        else if( this.isUI ) this.main.calc( -this.hplus );\r\n        \r\n        this.s[0].height = this.h +'px';\r\n        this.s[2].display = 'none';\r\n        this.s[4].display = 'none';\r\n        this.isShow = false;\r\n\r\n        if( !this.custom ) Roots.removeListen( this );\r\n\r\n        this.c[4].innerHTML = '';\r\n        \r\n    }\r\n\r\n\r\n    ///// AUTO FPS //////\r\n\r\n    begin () {\r\n\r\n        this.startTime = this.now();\r\n        \r\n    }\r\n\r\n    end () {\r\n\r\n        let time = this.now();\r\n        this.ms = time - this.startTime;\r\n\r\n        this.frames ++;\r\n\r\n        if ( time > this.prevTime + 1000 ) {\r\n\r\n            this.fps = this.round( ( this.frames * 1000 ) / ( time - this.prevTime ) );\r\n\r\n            this.prevTime = time;\r\n            this.frames = 0;\r\n\r\n            if ( this.isMem ) {\r\n\r\n                let heapSize = performance.memory.usedJSHeapSize;\r\n                let heapSizeLimit = performance.memory.jsHeapSizeLimit;\r\n\r\n                this.mem = this.round( heapSize * 0.000000954 );\r\n                this.mm = heapSize / heapSizeLimit;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        this.values = [ this.fps, this.ms , this.mm ];\r\n\r\n        this.drawGraph();\r\n        this.upText( [ this.fps, this.ms, this.mem ] );\r\n\r\n        return time;\r\n\r\n    }\r\n\r\n    listening () {\r\n\r\n        if( !this.custom ) this.startTime = this.end();\r\n        \r\n    }\r\n\r\n    rSize () {\r\n\r\n        let s = this.s;\r\n        let w = this.w;\r\n\r\n        s[0].width = w + 'px';\r\n        s[1].width = w + 'px';\r\n        s[2].left = 10 + 'px';\r\n        s[2].width = (w-20) + 'px';\r\n        s[4].width = (w-20) + 'px';\r\n        \r\n    }\r\n    \r\n}\n\nclass Graph extends Proto {\r\n\r\n    constructor( o = {} ) {\r\n\r\n        super( o );\r\n\r\n    \tthis.value = o.value !== undefined ? o.value : [0,0,0];\r\n        this.lng = this.value.length;\r\n\r\n        this.precision = o.precision !== undefined ? o.precision : 2;\r\n        this.multiplicator = o.multiplicator || 1;\r\n        this.neg = o.neg || false;\r\n\r\n        this.line = o.line !== undefined ?  o.line : true;\r\n\r\n        //if(this.neg)this.multiplicator*=2;\r\n\r\n        this.autoWidth = o.autoWidth !== undefined ? o.autoWidth : true;\r\n        this.isNumber = false;\r\n\r\n        this.isDown = false;\r\n\r\n        this.h = o.h || 128 + 10;\r\n        this.rh = this.h - 10;\r\n        this.top = 0;\r\n\r\n        this.c[0].style.width = this.w +'px';\r\n\r\n        if( this.c[1] !== undefined ) { // with title\r\n\r\n            this.c[1].style.width = this.w +'px';\r\n\r\n            if(!this.autoWidth){\r\n                this.c[1].style.width = '100%';\r\n                this.c[1].style.justifyContent = 'center';\r\n            }\r\n            \r\n            \r\n            //this.c[1].style.background = '#ff0000';\r\n            //this.c[1].style.textAlign = 'center';\r\n            this.top = 10;\r\n            this.h += 10;\r\n\r\n        }\r\n\r\n        this.gh = this.rh - 28;\r\n        this.gw = this.w - 28;\r\n\r\n        //this.c[2] = this.dom( 'div', this.css.txt + 'justify-content:center; text-align: justify; column-count:'+this.lng+'; top:'+(this.h-20)+'px; width:100%; color:'+ this.colors.text );\r\n\r\n        //let colum = 'column-count:'+this.lng+'; column:'+this.lng+'; break-inside: column; top:'\r\n        this.c[2] = this.dom( 'div', this.css.txt + 'display:block; text-align:center; padding:0px 0px; top:'+(this.h-20)+'px; left:14px; width:'+this.gw+'px;  color:'+ this.colors.text );\r\n       \r\n        //this.c[2].textContent = this.value;\r\n        this.c[2].innerHTML = this.valueToHtml();\r\n\r\n        let svg = this.dom( 'svg', this.css.basic , { viewBox:'0 0 '+this.w+' '+this.rh, width:this.w, height:this.rh, preserveAspectRatio:'none' } );\r\n        this.setCss( svg, { width:this.w, height:this.rh, left:0, top:this.top });\r\n\r\n        this.dom( 'path', '', { d:'', stroke:this.colors.text, 'stroke-width':2, fill:'none', 'stroke-linecap':'butt' }, svg );\r\n        this.dom( 'rect', '', { x:10, y:10, width:this.gw+8, height:this.gh+8, stroke:'rgba(0,0,0,0.3)', 'stroke-width':1 , fill:'none'}, svg );\r\n\r\n        this.iw = ((this.gw-(4*(this.lng-1)))/this.lng);\r\n        let t = [];\r\n        this.cMode = [];\r\n\r\n        this.v = [];\r\n\r\n        for( let i = 0; i < this.lng; i++ ){\r\n\r\n        \tt[i] = [ 14 + (i*this.iw) + (i*4), this.iw ];\r\n        \tt[i][2] = t[i][0] + t[i][1];\r\n        \tthis.cMode[i] = 0;\r\n\r\n            if( this.neg ) this.v[i] = ((1+(this.value[i] / this.multiplicator))*0.5);\r\n        \telse this.v[i] = this.value[i] / this.multiplicator;\r\n\r\n        \tthis.dom( 'rect', '', { x:t[i][0], y:14, width:t[i][1], height:1, fill:this.colors.text, 'fill-opacity':0.3 }, svg );\r\n\r\n        }\r\n\r\n        this.tmp = t;\r\n        this.c[3] = svg;\r\n\r\n        //console.log(this.w)\r\n\r\n        this.init();\r\n\r\n        if( this.c[1] !== undefined ){\r\n            this.c[1].style.top = 0 +'px';\r\n            this.c[1].style.height = 20 +'px';\r\n            this.s[1].lineHeight = (20-5)+'px';\r\n        }\r\n\r\n        this.update( false );\r\n\r\n    }\r\n\r\n    setValue ( value ) {\r\n\r\n        this.value = value;\r\n        this.lng = this.value.length;\r\n        for (var i = 0; i < this.lng; i++) {\r\n            if (this.neg) this.v[i] = (1 + value[i] / this.multiplicator) * 0.5;\r\n            else this.v[i] = value[i] / this.multiplicator;\r\n        }\r\n        this.update();\r\n\r\n    }\r\n\r\n    valueToHtml() {\r\n\r\n        let i = this.lng, n=0, r = '<table style=\"width:100%;\"><tr>';\r\n        let w = 100 / this.lng;\r\n        let style = 'width:'+ w +'%;';//' text-align:center;'\r\n        while(i--){\r\n            if(n===this.lng-1) r += '<td style='+style+'>' + this.value[n] + '</td></tr></table>';\r\n            else r += '<td style='+style+'>' + this.value[n] + '</td>';\r\n            n++;\r\n        }\r\n        return r\r\n    }\r\n\r\n    updateSVG () {\r\n\r\n        if( this.line ) this.setSvg( this.c[3], 'd', this.makePath(), 0 );\r\n\r\n        for(let i = 0; i<this.lng; i++ ){\r\n\r\n            this.setSvg( this.c[3], 'height', this.v[i]*this.gh, i+2 );\r\n            this.setSvg( this.c[3], 'y', 14 + (this.gh - this.v[i]*this.gh), i+2 );\r\n            if( this.neg ) this.value[i] = ( ((this.v[i]*2)-1) * this.multiplicator ).toFixed( this.precision ) * 1;\r\n            else this.value[i] = ( (this.v[i] * this.multiplicator) ).toFixed( this.precision ) * 1;\r\n\r\n        }\r\n\r\n        //this.c[2].textContent = this.value;\r\n        this.c[2].innerHTML = this.valueToHtml();\r\n\r\n    }\r\n\r\n    testZone ( e ) {\r\n\r\n        let l = this.local;\r\n        if( l.x === -1 && l.y === -1 ) return '';\r\n\r\n        let i = this.lng;\r\n        let t = this.tmp;\r\n        \r\n\t    if( l.y>this.top && l.y<this.h-20 ){\r\n\t        while( i-- ){\r\n\t            if( l.x>t[i][0] && l.x<t[i][2] ) return i;\r\n\t        }\r\n\t    }\r\n\r\n        return ''\r\n\r\n    }\r\n\r\n    mode ( n, name ) {\r\n\r\n    \tif( n === this.cMode[name] ) return false;\r\n\r\n    \tlet a;\r\n\r\n        switch(n){\r\n            case 0: a=0.3; break;\r\n            case 1: a=0.6; break;\r\n            case 2: a=1; break;\r\n        }\r\n\r\n        this.reset();\r\n\r\n        this.setSvg( this.c[3], 'fill-opacity', a, name + 2 );\r\n        this.cMode[name] = n;\r\n\r\n        return true;\r\n\r\n\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   EVENTS\r\n    // ----------------------\r\n\r\n    reset () {\r\n\r\n    \tlet nup = false;\r\n        //this.isDown = false;\r\n\r\n        let i = this.lng;\r\n        while(i--){ \r\n            if( this.cMode[i] !== 0 ){\r\n                this.cMode[i] = 0;\r\n                this.setSvg( this.c[3], 'fill-opacity', 0.3, i + 2 );\r\n                nup = true;\r\n            }\r\n        }\r\n\r\n        return nup;\r\n\r\n    }\r\n\r\n    mouseup ( e ) {\r\n\r\n        this.isDown = false;\r\n        if( this.current !== -1 ) return this.reset();\r\n        \r\n    }\r\n\r\n    mousedown ( e ) {\r\n\r\n    \tthis.isDown = true;\r\n        return this.mousemove( e );\r\n\r\n    }\r\n\r\n    mousemove ( e ) {\r\n\r\n    \tlet nup = false;\r\n\r\n    \tlet name = this.testZone(e);\r\n\r\n    \tif( name === '' ){\r\n\r\n            nup = this.reset();\r\n            //this.cursor();\r\n\r\n        } else { \r\n\r\n            nup = this.mode( this.isDown ? 2 : 1, name );\r\n            //this.cursor( this.current !== -1 ? 'move' : 'pointer' );\r\n            if(this.isDown){\r\n            \tthis.v[name] = this.clamp( 1 - (( e.clientY - this.zone.y - this.top - 10 ) / this.gh) , 0, 1 );\r\n            \tthis.update( true );\r\n            }\r\n\r\n        }\r\n\r\n        return nup;\r\n\r\n    }\r\n\r\n    // ----------------------\r\n\r\n    update ( up ) {\r\n\r\n    \tthis.updateSVG();\r\n\r\n        if( up ) this.send();\r\n\r\n    }\r\n\r\n    makePath () {\r\n\r\n    \tlet p = \"\", h, w, wn, wm, ow, oh;\r\n    \t//let g = this.iw*0.5\r\n\r\n    \tfor(let i = 0; i<this.lng; i++ ){\r\n\r\n    \t\th = 14 + (this.gh - this.v[i]*this.gh);\r\n    \t\tw = (14 + (i*this.iw) + (i*4));\r\n\r\n    \t\twm = w + this.iw*0.5;\r\n    \t\twn = w + this.iw;\r\n\r\n    \t\tif(i===0) p+='M '+w+' '+ h + ' T ' + wm +' '+ h;\r\n    \t\telse p += ' C ' + ow +' '+ oh + ',' + w +' '+ h + ',' + wm +' '+ h;\r\n    \t\tif(i === this.lng-1) p+=' T ' + wn +' '+ h;\r\n\r\n    \t\tow = wn;\r\n    \t\toh = h; \r\n\r\n    \t}\r\n\r\n    \treturn p;\r\n\r\n    }\r\n\r\n    rSize () {\r\n\r\n        super.rSize();\r\n\r\n        let s = this.s;\r\n        if( this.c[1] !== undefined ) s[1].width = this.w + 'px';\r\n        s[3].width = this.w + 'px';\r\n\r\n        let gw = this.w - 28;\r\n        let iw = ((gw-(4*(this.lng-1)))/this.lng);\r\n\r\n        let t = [];\r\n\r\n        s[2].width = gw + 'px';\r\n\r\n        for( let i = 0; i < this.lng; i++ ){\r\n\r\n            t[i] = [ 14 + (i*iw) + (i*4), iw ];\r\n            t[i][2] = t[i][0] + t[i][1];\r\n\r\n        }\r\n\r\n        this.tmp = t;\r\n\r\n    }\r\n\r\n}\n\nclass Group extends Proto {\r\n\r\n    constructor( o = {} ) {\r\n\r\n        super( o );\r\n\r\n        this.isGroup = true;\r\n\r\n        this.ADD = o.add;\r\n\r\n        this.autoHeight = true;\r\n\r\n        this.uis = [];\r\n        this.current = -1;\r\n        this.proto = null;\r\n        this.isEmpty = true;\r\n        this.decal = 0;\r\n\r\n        this.baseH = this.h;\r\n\r\n        let fltop = Math.floor(this.h*0.5)-6;\r\n\r\n        this.isLine = o.line !== undefined ? o.line : false;\r\n\r\n        this.decal = 0;\r\n\r\n        if( o.group ){\r\n            this.decal = o.group.decal ? o.group.decal : 0;\r\n            this.decal += 6;\r\n        }\r\n\r\n        this.useFlex = true; \r\n        let flexible = this.useFlex ? 'display:flex; flex-flow: row wrap;' : '';\r\n\r\n        this.c[2] = this.dom( 'div', this.css.basic + flexible + 'width:100%; left:0; height:auto; overflow:hidden; top:'+this.h+'px');// \r\n        this.c[3] = this.dom( 'path', this.css.basic + 'position:absolute; width:10px; height:10px; left:0; top:'+fltop+'px;', { d:this.svgs.group, fill:this.colors.text, stroke:'none'});\r\n        this.c[4] = this.dom( 'path', this.css.basic + 'position:absolute; width:10px; height:10px; left:'+(4+this.decal)+'px; top:'+fltop+'px;', { d:this.svgs.arrow, fill:this.colors.text, stroke:'none'});\r\n        // bottom line\r\n        if( this.isLine ) this.c[5] = this.dom( 'div', this.css.basic +  'background:rgba(255, 255, 255, 0.2); width:100%; left:0; height:1px; bottom:0px');\r\n\r\n        let s = this.s;\r\n        s[0].height = this.h + 'px';\r\n        s[1].height = this.h + 'px';\r\n        this.c[1].name = 'group';\r\n\r\n        s[1].marginLeft = (10+this.decal)+'px';\r\n        s[1].lineHeight = this.h-4;\r\n        s[1].color = this.colors.text;\r\n        s[1].fontWeight = 'bold';\r\n\r\n        if( this.radius !== 0 ) s[0].borderRadius = this.radius+'px';\r\n        this.init();\r\n\r\n        this.setBG( o.bg );\r\n\r\n        if( o.open !== undefined ) this.open();\r\n\r\n    }\r\n\r\n    testZone ( e ) {\r\n\r\n        let l = this.local;\r\n        if( l.x === -1 && l.y === -1 ) return '';\r\n\r\n        let name = '';\r\n\r\n        if( l.y < this.baseH ) name = 'title';\r\n        else {\r\n            if( this.isOpen ) name = 'content';\r\n        }\r\n\r\n        return name;\r\n\r\n    }\r\n\r\n    clearTarget () {\r\n\r\n        if( this.current === -1 ) return false;\r\n        if( this.proto.s ){\r\n            // if no s target is delete !!\r\n            this.proto.uiout();\r\n            this.proto.reset();\r\n        }\r\n        this.proto = null;\r\n        this.current = -1;\r\n        this.cursor();\r\n        return true;\r\n\r\n    }\r\n\r\n    reset () {\r\n\r\n        this.clearTarget();\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   EVENTS\r\n    // ----------------------\r\n\r\n    handleEvent ( e ) {\r\n\r\n        let type = e.type;\r\n\r\n        let change = false;\r\n        let protoChange = false;\r\n\r\n        let name = this.testZone( e );\r\n\r\n        if( !name ) return;\r\n\r\n        switch( name ){\r\n\r\n            case 'content':\r\n            this.cursor();\r\n\r\n            if( Roots.isMobile && type === 'mousedown' ) this.getNext( e, change );\r\n\r\n            if( this.proto ) protoChange = this.proto.handleEvent( e );\r\n\r\n            if( !Roots.lock ) this.getNext( e, change );\r\n\r\n            break;\r\n            case 'title':\r\n            this.cursor('pointer');\r\n            if( type === 'mousedown' ){\r\n                if( this.isOpen ) this.close();\r\n                else this.open();\r\n            }\r\n            break;\r\n\r\n\r\n        }\r\n\r\n        if( this.isDown ) change = true;\r\n        if( protoChange ) change = true;\r\n\r\n        return change;\r\n\r\n    }\r\n\r\n    getNext ( e, change ) {\r\n\r\n        let next = Roots.findTarget( this.uis, e );\r\n\r\n        if( next !== this.current ){\r\n            this.clearTarget();\r\n            this.current = next;\r\n        }\r\n\r\n        if( next !== -1 ){ \r\n            this.proto  = this.uis[ this.current ];\r\n            this.proto.uiover();\r\n        }\r\n\r\n    }\r\n\r\n    // ----------------------\r\n\r\n    setBG ( bg ) {\r\n\r\n        if( bg !== undefined ) this.colors.background = bg;\r\n\r\n        this.c[0].style.background = this.colors.background;\r\n\r\n        let i = this.uis.length;\r\n        while(i--){\r\n            this.uis[i].setBG( this.colors.background );\r\n        }\r\n\r\n    }\r\n\r\n    add() {\r\n\r\n        let a = arguments;\r\n\r\n        if( typeof a[1] === 'object' ){ \r\n            a[1].isUI = this.isUI;\r\n            a[1].target = this.c[2];\r\n            a[1].main = this.main;\r\n            a[1].group = this;\r\n        } else if( typeof arguments[1] === 'string' ){\r\n            if( a[2] === undefined ) [].push.call( a, { isUI:true, target:this.c[2], main:this.main });\r\n            else { \r\n                a[2].isUI = true;\r\n                a[2].target = this.c[2];\r\n                a[2].main = this.main;\r\n                a[2].group = this;\r\n            }\r\n        }\r\n\r\n        let u = this.ADD.apply( this, a );\r\n\r\n        this.uis.push( u );\r\n\r\n        this.isEmpty = false;\r\n\r\n        return u;\r\n\r\n    }\r\n\r\n    // remove one node\r\n\r\n    remove ( n ) {\r\n\r\n        if( n.dispose ) n.dispose();\r\n\r\n    }\r\n\r\n    // clear all iner \r\n\r\n    dispose() {\r\n\r\n        this.clear();\r\n        if( this.isUI ) this.main.calc();\r\n        super.dispose();\r\n\r\n    }\r\n\r\n    clear() {\r\n\r\n        this.empty();\r\n\r\n    }\r\n\r\n    empty () {\r\n\r\n        this.close();\r\n\r\n        let i = this.uis.length, item;\r\n\r\n        while( i-- ){\r\n            item = this.uis.pop();\r\n            this.c[2].removeChild( item.c[0] );\r\n            item.clear( true );\r\n\r\n            //this.uis[i].clear()\r\n        }\r\n\r\n        this.isEmpty = true;\r\n        this.h = this.baseH;\r\n\r\n    }\r\n\r\n    // clear one element\r\n\r\n    clearOne ( n ) { \r\n\r\n        let id = this.uis.indexOf( n );\r\n\r\n        if ( id !== -1 ) {\r\n            this.calc( - ( this.uis[ id ].h + 1 ) );\r\n            this.c[2].removeChild( this.uis[ id ].c[0] );\r\n            this.uis.splice( id, 1 ); \r\n\r\n            if( this.uis.length === 0 ){ \r\n                this.isEmpty = true;\r\n                this.close();\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    \r\n\r\n    open () {\r\n\r\n        super.open();\r\n\r\n        this.setSvg( this.c[4], 'd', this.svgs.arrowDown );\r\n        this.rSizeContent();\r\n\r\n        this.h - this.baseH;\r\n\r\n        this.parentHeight();\r\n\r\n    }\r\n\r\n    close () {\r\n\r\n        super.close();\r\n\r\n        this.h - this.baseH;\r\n\r\n        this.setSvg( this.c[4], 'd', this.svgs.arrow );\r\n        this.h = this.baseH;\r\n        this.s[0].height = this.h + 'px';\r\n\r\n        this.parentHeight();\r\n\r\n    }\r\n\r\n    calcUis () {\r\n\r\n        if( !this.isOpen ) this.h = this.baseH;\r\n        else this.h = Roots.calcUis( this.uis, this.zone, this.zone.y + this.baseH ) + this.baseH;\r\n\r\n        this.s[0].height = this.h + 'px';\r\n\r\n    }\r\n\r\n    parentHeight ( t ) {\r\n\r\n        if ( this.group !== null ) this.group.calc( t );\r\n        else if ( this.isUI ) this.main.calc( t );\r\n\r\n    }\r\n\r\n    calc ( y ) {\r\n\r\n        if( !this.isOpen ) return\r\n        if( this.isUI ) this.main.calc();\r\n        else this.calcUis();\r\n        this.s[0].height = this.h + 'px';\r\n\r\n    }\r\n\r\n    rSizeContent () {\r\n\r\n        let i = this.uis.length;\r\n        while(i--){\r\n            this.uis[i].setSize( this.w );\r\n            this.uis[i].rSize();\r\n        }\r\n\r\n    }\r\n\r\n    rSize () {\r\n\r\n        super.rSize();\r\n\r\n        let s = this.s;\r\n\r\n        s[3].left = ( this.sa + this.sb - 17 ) + 'px';\r\n        s[1].width = this.w + 'px';\r\n        s[2].width = this.w + 'px';\r\n\r\n        if( this.isOpen ) this.rSizeContent();\r\n\r\n    }\r\n\r\n}\n\nclass Joystick extends Proto {\r\n\r\n    constructor( o = {} ) {\r\n\r\n        super( o );\r\n\r\n        this.autoWidth = false;\r\n\r\n        this.value = [0,0];\r\n\r\n        this.minw  = this.w;\r\n        this.diam = o.diam || this.w; \r\n\r\n        this.joyType = 'analogique';\r\n        this.model = o.mode !== undefined ? o.mode : 0;\r\n\r\n        this.precision = o.precision || 2;\r\n        this.multiplicator = o.multiplicator || 1;\r\n\r\n        this.pos = new V2();\r\n        this.tmp = new V2();\r\n\r\n        this.interval = null;\r\n        this.c[0].style.display = 'block';\r\n\r\n        //this.radius = this.w * 0.5;\r\n        //this.distance = this.radius*0.25;\r\n        this.distance = (this.diam*0.5)*0.25;\r\n\r\n        this.h = o.h || this.w + 10;\r\n        this.top = 0;\r\n\r\n        this.c[0].style.width = this.w +'px';\r\n\r\n        if( this.c[1] !== undefined ) { // with title\r\n\r\n            this.c[1].style.width = '100%';\r\n            this.c[1].style.justifyContent = 'center';\r\n            this.top = 10;\r\n            this.h += 10;\r\n\r\n        }\r\n\r\n        let cc = this.colors;\r\n\r\n        this.c[2] = this.dom( 'div', this.css.txt + 'justify-content:center; top:'+(this.h-20)+'px; width:100%; color:'+ cc.text );\r\n        this.c[2].textContent = this.value;\r\n\r\n        this.c[3] = this.getJoystick( this.model );\r\n        this.setSvg( this.c[3], 'viewBox', '0 0 '+this.diam+' '+this.diam );\r\n        this.setCss( this.c[3], { width:this.diam, height:this.diam, left:0, top:this.top });\r\n\r\n\r\n        this.ratio = 128/this.w;\r\n\r\n        this.init();\r\n\r\n        this.update(false);\r\n        \r\n    }\r\n\r\n    mode ( mode ) {\r\n\r\n        let cc = this.colors;\r\n\r\n        switch(mode){\r\n            case 0: // base\r\n                if(this.model===0){\r\n                    this.setSvg( this.c[3], 'fill', 'url(#gradIn)', 4 );\r\n                    this.setSvg( this.c[3], 'stroke', '#000', 4 );\r\n                } else {\r\n                    this.setSvg( this.c[3], 'stroke', 'rgba(100,100,100,0.25)', 2 );\r\n                    //this.setSvg( this.c[3], 'stroke', 'rgb(0,0,0,0.1)', 3 );\r\n                    this.setSvg( this.c[3], 'stroke', '#666', 4 );\r\n                    this.setSvg( this.c[3], 'fill', 'none', 4 );\r\n                }\r\n                \r\n            break;\r\n            case 1: // over\r\n                if(this.model===0){\r\n                    this.setSvg( this.c[3], 'fill', 'url(#gradIn2)', 4 );\r\n                    this.setSvg( this.c[3], 'stroke', 'rgba(0,0,0,0)', 4 );\r\n                } else {\r\n                    this.setSvg( this.c[3], 'stroke', 'rgba(48,138,255,0.25)', 2 );\r\n                    //this.setSvg( this.c[3], 'stroke', 'rgb(0,0,0,0.3)', 3 );\r\n                    this.setSvg( this.c[3], 'stroke', cc.select, 4 );\r\n                    this.setSvg( this.c[3], 'fill', 'rgba(48,138,255,0.25)', 4 );\r\n                }\r\n            break;\r\n\r\n        }\r\n    }\r\n\r\n    // ----------------------\r\n    //   EVENTS\r\n    // ----------------------\r\n\r\n    addInterval (){\r\n        if( this.interval !== null ) this.stopInterval();\r\n        if( this.pos.isZero() ) return;\r\n        this.interval = setInterval( function(){ this.update(); }.bind(this), 10 );\r\n\r\n    }\r\n\r\n    stopInterval (){\r\n\r\n        if( this.interval === null ) return;\r\n        clearInterval( this.interval );\r\n        this.interval = null;\r\n\r\n    }\r\n\r\n    reset () {\r\n\r\n        this.addInterval();\r\n        this.mode(0);\r\n\r\n    }\r\n\r\n    mouseup ( e ) {\r\n\r\n        this.addInterval();\r\n        this.isDown = false;\r\n    \r\n    }\r\n\r\n    mousedown ( e ) {\r\n\r\n        this.isDown = true;\r\n        this.mousemove( e );\r\n        this.mode( 2 );\r\n\r\n    }\r\n\r\n    mousemove ( e ) {\r\n\r\n        this.mode(1);\r\n\r\n        if( !this.isDown ) return;\r\n\r\n        //this.tmp.x = this.radius - ( e.clientX - this.zone.x );\r\n        //this.tmp.y = this.radius - ( e.clientY - this.zone.y - this.top );\r\n\r\n        this.tmp.x = (this.w*0.5) - ( e.clientX - this.zone.x );\r\n        this.tmp.y = (this.diam*0.5) - ( e.clientY - this.zone.y - this.top );\r\n\r\n        let distance = this.tmp.length();\r\n\r\n        if ( distance > this.distance ) {\r\n            let angle = Math.atan2(this.tmp.x, this.tmp.y);\r\n            this.tmp.x = Math.sin( angle ) * this.distance;\r\n            this.tmp.y = Math.cos( angle ) * this.distance;\r\n        }\r\n\r\n        this.pos.copy( this.tmp ).divideScalar( this.distance ).negate();\r\n\r\n        this.update();\r\n\r\n    }\r\n\r\n    setValue ( v ) {\r\n\r\n        if(v===undefined) v=[0,0];\r\n\r\n        this.pos.set( v[0] || 0, v[1]  || 0 );\r\n        this.updateSVG();\r\n\r\n    }\r\n\r\n    update ( up ) {\r\n\r\n        if( up === undefined ) up = true;\r\n\r\n        if( this.interval !== null ){\r\n\r\n            if( !this.isDown ){\r\n\r\n                this.pos.lerp( null, 0.3 );\r\n\r\n                this.pos.x = Math.abs( this.pos.x ) < 0.01 ? 0 : this.pos.x;\r\n                this.pos.y = Math.abs( this.pos.y ) < 0.01 ? 0 : this.pos.y;\r\n\r\n                if( this.isUI && this.main.isCanvas ) this.main.draw();\r\n\r\n            }\r\n\r\n        }\r\n\r\n        this.updateSVG();\r\n\r\n        if( up ) this.send();\r\n        \r\n\r\n        if( this.pos.isZero() ) this.stopInterval();\r\n\r\n    }\r\n\r\n    updateSVG () {\r\n\r\n        //let x = this.radius - ( -this.pos.x * this.distance );\r\n        //let y = this.radius - ( -this.pos.y * this.distance );\r\n\r\n        let x = (this.diam*0.5) - ( -this.pos.x * this.distance );\r\n        let y = (this.diam*0.5) - ( -this.pos.y * this.distance );\r\n\r\n         if(this.model === 0){\r\n\r\n            let sx = x + ((this.pos.x)*5) + 5;\r\n            let sy = y + ((this.pos.y)*5) + 10;\r\n\r\n            this.setSvg( this.c[3], 'cx', sx*this.ratio, 3 );\r\n            this.setSvg( this.c[3], 'cy', sy*this.ratio, 3 );\r\n        } else {\r\n            this.setSvg( this.c[3], 'cx', x*this.ratio, 3 );\r\n            this.setSvg( this.c[3], 'cy', y*this.ratio, 3 );\r\n        }\r\n\r\n        \r\n\r\n        this.setSvg( this.c[3], 'cx', x*this.ratio, 4 );\r\n        this.setSvg( this.c[3], 'cy', y*this.ratio, 4 );\r\n\r\n        this.value[0] =  ( this.pos.x * this.multiplicator ).toFixed( this.precision ) * 1;\r\n        this.value[1] =  ( this.pos.y * this.multiplicator ).toFixed( this.precision ) * 1;\r\n\r\n        this.c[2].textContent = this.value;\r\n\r\n    }\r\n\r\n    clear () {\r\n        \r\n        this.stopInterval();\r\n        super.clear();\r\n\r\n    }\r\n\r\n}\n\nclass Knob extends Proto {\r\n\r\n    constructor( o = {} ) {\r\n\r\n        super( o );\r\n\r\n        this.isCyclic = o.cyclic || false;\r\n        this.model = o.stype || 0;\r\n        if( o.mode !== undefined ) this.model = o.mode;\r\n\r\n        this.autoWidth = false;\r\n\r\n        this.setTypeNumber( o );\r\n\r\n        this.minw  = this.w;\r\n        this.diam = o.diam || this.w; \r\n\r\n        this.mPI = Math.PI * 0.8;\r\n        this.toDeg = 180 / Math.PI;\r\n        this.cirRange = this.mPI * 2;\r\n\r\n        this.offset = new V2();\r\n\r\n        this.h = o.h || this.w + 10;\r\n        this.top = 0;\r\n\r\n        this.c[0].style.width = this.w +'px';\r\n        this.c[0].style.display = 'block';\r\n\r\n        if(this.c[1] !== undefined) {\r\n\r\n            this.c[1].style.width = '100%';\r\n            this.c[1].style.justifyContent = 'center';\r\n            this.top = 10;\r\n            this.h += 10;\r\n\r\n        }\r\n\r\n        this.percent = 0;\r\n\r\n        this.cmode = 0;\r\n        let cc = this.colors;\r\n\r\n        this.c[2] = this.dom( 'div', this.css.txt + 'justify-content:center; top:'+(this.h-20)+'px; width:100%; color:'+ cc.text );\r\n\r\n        this.c[3] = this.getKnob();\r\n        this.setSvg( this.c[3], 'fill', cc.button, 0 );\r\n        this.setSvg( this.c[3], 'stroke', cc.text, 1 );\r\n        this.setSvg( this.c[3], 'stroke', cc.text, 3 );\r\n        this.setSvg( this.c[3], 'd', this.makeGrad(), 3 );\r\n        \r\n        this.setSvg( this.c[3], 'viewBox', '0 0 ' + this.diam + ' ' + this.diam );\r\n        this.setCss( this.c[3], { width:this.diam, height:this.diam, left:0, top:this.top });\r\n\r\n        if ( this.model > 0 ) {\r\n\r\n            Tools.dom( 'path', '', { d: '', stroke:cc.text, 'stroke-width': 2, fill: 'none', 'stroke-linecap': 'round' }, this.c[3] ); //4\r\n\r\n            if ( this.model == 2) {\r\n            \r\n                Tools.addSVGGlowEffect();\r\n                this.setSvg( this.c[3], 'style', 'filter: url(\"#UILGlow\");', 4 );\r\n            \r\n            }\r\n\r\n        }\r\n\r\n        this.r = 0;\r\n\r\n        this.init();\r\n\r\n        this.update();\r\n\r\n    }\r\n\r\n    mode ( mode ) {\r\n\r\n        let cc = this.colors;\r\n\r\n        if( this.cmode === mode ) return false;\r\n\r\n        switch( mode ) {\r\n            case 0: // base\r\n                this.s[2].color = cc.text;\r\n                this.setSvg( this.c[3], 'fill', cc.button, 0);\r\n                //this.setSvg( this.c[3], 'stroke','rgba(255,0,0,0.2)', 2);\r\n                this.setSvg( this.c[3], 'stroke', cc.text, 1 );\r\n            break;\r\n            case 1: // down\r\n                this.s[2].color = cc.textOver;\r\n                this.setSvg( this.c[3], 'fill', cc.select, 0);\r\n                //this.setSvg( this.c[3], 'stroke','rgba(0,0,0,0.6)', 2);\r\n                this.setSvg( this.c[3], 'stroke', cc.textOver, 1 );\r\n            break;\r\n        }\r\n\r\n        this.cmode = mode;\r\n        return true;\r\n\r\n    }\r\n\r\n    testZone ( e ) {\r\n\r\n        let l = this.local;\r\n        if( l.x === -1 && l.y === -1 ) return '';\r\n        if( l.y <= this.c[ 1 ].offsetHeight ) return 'title';\r\n        else if ( l.y > this.h - this.c[ 2 ].offsetHeight ) return 'text';\r\n        else return 'knob';\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   EVENTS\r\n    // ----------------------\r\n\r\n    mouseup ( e ) {\r\n\r\n        this.isDown = false;\r\n        this.sendEnd();\r\n        return this.mode(0)\r\n\r\n    }\r\n\r\n    mousedown ( e ) {\r\n\r\n        this.isDown = true;\r\n        this.old = this.value;\r\n        this.oldr = null;\r\n        this.mousemove( e );\r\n        return this.mode(1)\r\n\r\n    }\r\n\r\n    mousemove ( e ) {\r\n\r\n        if( !this.isDown ) return;\r\n\r\n        let off = this.offset;\r\n\r\n        //off.x = this.radius - ( e.clientX - this.zone.x );\r\n        //off.y = this.radius - ( e.clientY - this.zone.y - this.top );\r\n\r\n        off.x = (this.w*0.5) - ( e.clientX - this.zone.x );\r\n        off.y = (this.diam*0.5) - ( e.clientY - this.zone.y - this.top );\r\n\r\n        this.r = - Math.atan2( off.x, off.y );\r\n\r\n        if( this.oldr !== null ) this.r = Math.abs(this.r - this.oldr) > Math.PI ? this.oldr : this.r;\r\n\r\n        this.r = this.r > this.mPI ? this.mPI : this.r;\r\n        this.r = this.r < -this.mPI ? -this.mPI : this.r;\r\n\r\n        let steps = 1 / this.cirRange;\r\n        let value = (this.r + this.mPI) * steps;\r\n\r\n        let n = ( ( this.range * value ) + this.min ) - this.old;\r\n\r\n        if(n >= this.step || n <= this.step){ \r\n            n = Math.floor( n / this.step );\r\n            this.value = this.numValue( this.old + ( n * this.step ) );\r\n            this.update( true );\r\n            this.old = this.value;\r\n            this.oldr = this.r;\r\n        }\r\n\r\n    }\r\n\r\n    wheel ( e ) {\r\n\r\n        let name = this.testZone( e );\r\n\r\n        if( name === 'knob' ) {\r\n    \r\n            let v = this.value - this.step * e.delta;\r\n    \r\n            if ( v > this.max ) {\r\n                v = this.isCyclic ? this.min : this.max;\r\n            } else if ( v < this.min ) {\r\n                v = this.isCyclic ? this.max : this.min;\r\n            }\r\n    \r\n            this.setValue( v );\r\n            this.old = v;\r\n            this.update( true );\r\n\r\n            return true;\r\n    \r\n        }\r\n        return false;\r\n\r\n    }\r\n\r\n    makeGrad () {\r\n\r\n        let d = '', step, range, a, x, y, x2, y2, r = 64;\r\n        let startangle = Math.PI + this.mPI;\r\n        let endangle = Math.PI - this.mPI;\r\n        //let step = this.step>5 ? this.step : 1;\r\n\r\n        if(this.step>5){\r\n            range =  this.range / this.step;\r\n            step = ( startangle - endangle ) / range;\r\n        } else {\r\n            step = (( startangle - endangle ) / r)*2;\r\n            range = r*0.5;\r\n        }\r\n\r\n        for ( let i = 0; i <= range; ++i ) {\r\n\r\n            a = startangle - ( step * i );\r\n            x = r + Math.sin( a ) * ( r - 20 );\r\n            y = r + Math.cos( a ) * ( r - 20 );\r\n            x2 = r + Math.sin( a ) * ( r - 24 );\r\n            y2 = r + Math.cos( a ) * ( r - 24 );\r\n            d += 'M' + x + ' ' + y + ' L' + x2 + ' '+y2 + ' ';\r\n\r\n        }\r\n\r\n        return d;\r\n\r\n    }\r\n\r\n    update ( up ) {\r\n\r\n        this.c[2].textContent = this.value;\r\n        this.percent = (this.value - this.min) / this.range;\r\n\r\n        let sa = Math.PI + this.mPI;\r\n        let ea = ( ( this.percent * this.cirRange ) - ( this.mPI ) );\r\n\r\n        let sin = Math.sin( ea );\r\n        let cos = Math.cos( ea );\r\n\r\n        let x1 = ( 25 * sin ) + 64;\r\n        let y1 = -( 25 * cos ) + 64;\r\n        let x2 = ( 20 * sin ) + 64;\r\n        let y2 = -( 20 * cos ) + 64;\r\n\r\n        this.setSvg( this.c[3], 'd', 'M ' + x1 +' ' + y1 + ' L ' + x2 +' ' + y2, 1 );\r\n        \r\n        if ( this.model > 0 ) {\r\n\r\n            let x1 = 36 * Math.sin( sa ) + 64;\r\n            let y1 = 36 * Math.cos( sa ) + 64;\r\n            let x2 = 36 * sin + 64;\r\n            let y2 = -36 * cos + 64;\r\n            let big = ea <= Math.PI - this.mPI ? 0 : 1;\r\n            this.setSvg( this.c[3], 'd', 'M ' + x1 + ',' + y1 + ' A ' + 36 + ',' + 36 + ' 1 ' + big + ' 1 ' + x2 + ',' + y2, 4 );\r\n\r\n            let color = Tools.pack( Tools.lerpColor( Tools.unpack( Tools.ColorLuma( this.colors.text, -0.75) ), Tools.unpack( this.colors.text ), this.percent ) );\r\n            this.setSvg( this.c[3], 'stroke', color, 4 );\r\n        \r\n        }\r\n\r\n        if( up ) this.send();\r\n        \r\n    }\r\n\r\n}\n\nclass List extends Proto {\r\n\r\n    constructor( o = {} ) {\r\n\r\n        super( o );\r\n\r\n        // images\r\n        this.path = o.path || '';\r\n        this.format = o.format || '';\r\n        \r\n\r\n        this.isWithImage = this.path !== '' ? true:false;\r\n        this.preLoadComplete = false;\r\n\r\n        this.tmpImage = {};\r\n        this.tmpUrl = [];\r\n\r\n        //this.autoHeight = false;\r\n\r\n        let align = o.align || 'center';\r\n\r\n        // scroll size\r\n        let ss = o.scrollSize || 10;\r\n        this.ss = ss+1;\r\n\r\n        this.sMode = 0;\r\n        this.tMode = 0;\r\n\r\n        this.listOnly = o.listOnly || false;\r\n        this.staticTop = o.staticTop || false;\r\n\r\n        this.isSelectable = this.listOnly;\r\n        if( o.select !== undefined ) o.selectable = o.select;\r\n        if( o.selectable !== undefined ) this.isSelectable = o.selectable;\r\n\r\n        if( this.txt === '' ) this.p = 0;\r\n\r\n\r\n        let fltop = Math.floor(this.h*0.5)-5;\r\n        let cc = this.colors;\r\n\r\n\r\n\r\n        this.c[2] = this.dom( 'div', this.css.basic + 'top:0; display:none; border-radius:'+this.radius+'px;' );\r\n        this.c[3] = this.dom( 'div', this.css.item + 'position:absolute; text-align:'+align+'; line-height:'+(this.h-4)+'px; top:1px; background:'+cc.button+'; height:'+(this.h-2)+'px; border:1px solid '+cc.border+'; border-radius:'+this.radius+'px;' );\r\n        this.c[4] = this.dom( 'path', this.css.basic + 'position:absolute; width:10px; height:10px; top:'+fltop+'px;', { d:this.svgs.arrow, fill:cc.text, stroke:'none'});\r\n\r\n        this.scrollerBack = this.dom( 'div', this.css.basic + 'right:0px; width:'+ss+'px; background:'+cc.back+'; display:none;');\r\n        this.scroller = this.dom( 'div', this.css.basic + 'right:'+((ss-(ss*0.25))*0.5)+'px; width:'+(ss*0.25)+'px; background:'+cc.text+'; display:none; ');\r\n\r\n        this.c[3].style.color = cc.text;\r\n\r\n\r\n        this.list = [];\r\n        this.refObject = null;\r\n\r\n        if(o.list){\r\n            if( o.list instanceof Array ){\r\n                this.list = o.list;\r\n            } else {\r\n                this.refObject = o.list;\r\n                for( let g in this.refObject ) this.list.push(g);\r\n            }\r\n        }\r\n\r\n        this.items = [];\r\n\r\n        this.prevName = '';\r\n\r\n        this.baseH = this.h;\r\n\r\n        this.itemHeight = o.itemHeight || (this.h-3);\r\n\r\n        // force full list \r\n        this.full = o.full || false;\r\n\r\n        this.py = 0;\r\n        this.ww = this.sb;\r\n        this.scroll = false;\r\n        this.isDown = false;\r\n\r\n        this.current = null;\r\n\r\n        // list up or down\r\n        this.side = o.side || 'down';\r\n        this.up = this.side === 'down' ? 0 : 1;\r\n\r\n        if( this.up ){\r\n\r\n            this.c[2].style.top = 'auto';\r\n            this.c[3].style.top = 'auto';\r\n            this.c[4].style.top = 'auto';\r\n            //this.c[5].style.top = 'auto';\r\n\r\n            this.c[2].style.bottom = this.h-2 + 'px';\r\n            this.c[3].style.bottom = '1px';\r\n            this.c[4].style.bottom = fltop + 'px';\r\n\r\n        } else {\r\n            this.c[2].style.top = this.baseH + 'px';\r\n        }\r\n\r\n        this.listIn = this.dom( 'div', this.css.basic + 'left:0; top:0; width:100%; background:none;');\r\n        this.listIn.name = 'list';\r\n\r\n\r\n\r\n        this.topList = 0;\r\n        \r\n        this.c[2].appendChild( this.listIn );\r\n        this.c[2].appendChild( this.scrollerBack );\r\n        this.c[2].appendChild( this.scroller );\r\n\r\n        if( o.value !== undefined ){\r\n            if(!isNaN(o.value)) this.value = this.list[ o.value ];\r\n            else this.value = o.value;\r\n        }else {\r\n            this.value = this.list[0];\r\n        }\r\n\r\n        this.isOpenOnStart = o.open || false;\r\n\r\n        if( this.listOnly ){\r\n            this.baseH = 5;\r\n            this.c[3].style.display = 'none';\r\n            this.c[4].style.display = 'none';\r\n            this.c[2].style.top = this.baseH+'px';\r\n            this.isOpenOnStart = true;\r\n        }\r\n\r\n\r\n        this.miniCanvas = o.miniCanvas || false; \r\n        this.canvasBg = o.canvasBg || 'rgba(0,0,0,0)';\r\n        this.imageSize = o.imageSize || [20,20];\r\n\r\n        // dragout function\r\n        this.drag = o.drag || false;\r\n        this.dragout = o.dragout || false;\r\n        this.dragstart = o.dragstart || null;\r\n        this.dragend = o.dragend || null;\r\n\r\n        \r\n\r\n        //this.c[0].style.background = '#FF0000'\r\n        if( this.isWithImage ) this.preloadImage();\r\n       // } else {\r\n            // populate list\r\n            this.setList( this.list );\r\n            this.init();\r\n            if( this.isOpenOnStart ) this.open( true );\r\n       // }\r\n\r\n    }\r\n\r\n    /*send ( v ) {\r\n\r\n        super.send( v );\r\n\r\n        //Proto.prototype.send.call( this, v );\r\n    }*/\r\n\r\n    // image list\r\n\r\n    preloadImage () {\r\n\r\n        this.preLoadComplete = false;\r\n\r\n        this.tmpImage = {};\r\n        for( let i=0; i<this.list.length; i++ ) this.tmpUrl.push( this.list[i] );\r\n        this.loadOne();\r\n        \r\n    }\r\n\r\n    nextImg () {\r\n\r\n        this.tmpUrl.shift();\r\n        if( this.tmpUrl.length === 0 ){ \r\n\r\n            this.preLoadComplete = true;\r\n\r\n            this.addImages();\r\n            /*this.setList( this.list );\r\n            this.init();\r\n            if( this.isOpenOnStart ) this.open();*/\r\n\r\n        }\r\n        else this.loadOne();\r\n\r\n    }\r\n\r\n    loadOne(){\r\n\r\n        let self = this;\r\n        let name = this.tmpUrl[0];\r\n        let img = document.createElement('img');\r\n        img.style.cssText = 'position:absolute; width:'+self.imageSize[0]+'px; height:'+self.imageSize[1]+'px';\r\n        img.setAttribute('src', this.path + name + this.format );\r\n\r\n        img.addEventListener('load', function() {\r\n\r\n            self.imageSize[2] = img.width;\r\n            self.imageSize[3] = img.height;\r\n            self.tmpImage[name] = img;\r\n            self.nextImg();\r\n\r\n        });\r\n\r\n    }\r\n\r\n    //\r\n\r\n    testZone ( e ) {\r\n\r\n        let l = this.local;\r\n        if( l.x === -1 && l.y === -1 ) return '';\r\n\r\n        if( this.up && this.isOpen ){\r\n            if( l.y > this.h - this.baseH ) return 'title';\r\n            else {\r\n                if( this.scroll && ( l.x > (this.sa+this.sb-this.ss)) ) return 'scroll';\r\n                if(l.x > this.sa) return this.testItems( l.y-this.baseH );\r\n            }\r\n\r\n        } else {\r\n            if( l.y < this.baseH+2 ) return 'title';\r\n            else {\r\n                if( this.isOpen ){\r\n                    if( this.scroll && ( l.x > (this.sa+this.sb-this.ss)) ) return 'scroll';\r\n                    if(l.x > this.sa) return this.testItems( l.y-this.baseH );\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        return '';\r\n\r\n    }\r\n\r\n    testItems ( y ) {\r\n\r\n        let name = '';\r\n\r\n        let i = this.items.length, item, a, b;\r\n        while(i--){\r\n            item = this.items[i];\r\n            a = item.posy + this.topList;\r\n            b = item.posy + this.itemHeight + 1 + this.topList;\r\n            if( y >= a && y <= b ){ \r\n                name = 'item' + i;\r\n                this.modeItem(0);\r\n                this.current = item;\r\n                this.modeItem(1);\r\n                return name;\r\n            }\r\n\r\n        }\r\n\r\n        return name;\r\n\r\n    }\r\n\r\n    modeItem ( mode ) {\r\n\r\n        if( !this.current ) return\r\n\r\n        if( this.current.select && mode===0) mode = 2;\r\n        let cc = this.colors;\r\n\r\n        switch( mode ){\r\n\r\n            case 0: // base\r\n                this.current.style.background = cc.back;\r\n                this.current.style.color = cc.text;\r\n            break;\r\n            case 1: // over\r\n                this.current.style.background = cc.over;\r\n                this.current.style.color = cc.textOver;\r\n            break;\r\n            case 2: // edit / down\r\n                this.current.style.background = cc.select;\r\n                this.current.style.color = cc.textSelect;\r\n            break;\r\n\r\n        }\r\n    }\r\n\r\n    unSelected() {\r\n\r\n        if( !this.current ) return\r\n        this.modeItem(0);\r\n        this.current = null;\r\n\r\n    }\r\n\r\n    selected() {\r\n\r\n        if( !this.current ) return\r\n        this.resetItems();\r\n        this.modeItem(2);\r\n        this.current.select = true;\r\n\r\n    }\r\n\r\n    resetItems() {\r\n\r\n        let i = this.items.length;\r\n        while(i--){\r\n            this.items[i].select = false;\r\n            this.items[i].style.background = this.colors.back;\r\n            this.items[i].style.color = this.colors.text;\r\n        }\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   EVENTS\r\n    // ----------------------\r\n\r\n\r\n    mouseup ( e ) {\r\n\r\n        this.isDown = false;\r\n\r\n    }\r\n\r\n    mousedown ( e ) {\r\n\r\n        let name = this.testZone( e );\r\n\r\n        if( !name ) return false;\r\n\r\n        if( name === 'scroll' ){\r\n\r\n            this.isDown = true;\r\n            this.mousemove( e );\r\n\r\n        } else if( name === 'title' ){\r\n\r\n            this.modeTitle(2);\r\n            if( !this.listOnly ){\r\n                if( !this.isOpen ) this.open();\r\n                else this.close();\r\n            }\r\n        } else {\r\n            // is item\r\n            if( this.current ){\r\n\r\n                this.value = this.list[ this.current.id ];\r\n\r\n                if( this.isSelectable ) this.selected();\r\n                //this.value = this.refObject !== null ? this.refObject[this.list[this.current.id]]  : this.list[this.current.id]\r\n                //this.value = this.current.textContent;\r\n                this.send( this.refObject !== null ? this.refObject[this.list[this.current.id]] : this.value );\r\n\r\n                if( !this.listOnly ) {\r\n                    this.close();\r\n                    this.setTopItem();\r\n                }\r\n            }\r\n            \r\n        }\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n    mousemove ( e ) {\r\n\r\n        let nup = false;\r\n        let name = this.testZone( e );\r\n\r\n        if( !name ) return nup;\r\n\r\n        if( name === 'title' ){\r\n            this.unSelected();\r\n            this.modeTitle(1);\r\n            this.cursor('pointer');\r\n\r\n        } else if( name === 'scroll' ){\r\n\r\n            this.cursor('s-resize');\r\n            this.modeScroll(1);\r\n            if( this.isDown ){\r\n                this.modeScroll(2);\r\n                let top = this.zone.y+this.baseH-2;\r\n                this.update( ( e.clientY - top  ) - ( this.sh*0.5 ) );\r\n            }\r\n            //if(this.isDown) this.listmove(e);\r\n        } else {\r\n\r\n            // is item\r\n            this.modeTitle(0);\r\n            this.modeScroll(0);\r\n            this.cursor('pointer');\r\n        \r\n        }\r\n\r\n        if( name !== this.prevName ) nup = true;\r\n        this.prevName = name;\r\n\r\n        return nup;\r\n\r\n    }\r\n\r\n    wheel ( e ) {\r\n\r\n        let name = this.testZone( e );\r\n        if( name === 'title' ) return false; \r\n        this.py += e.delta*10;\r\n        this.update(this.py);\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n\r\n    // ----------------------\r\n\r\n    reset () {\r\n\r\n        this.prevName = '';\r\n        this.unSelected();\r\n        this.modeTitle(0);\r\n        this.modeScroll(0);\r\n\r\n        //console.log('this is reset')\r\n        \r\n    }\r\n\r\n    modeScroll ( mode ) {\r\n\r\n        if( mode === this.sMode ) return;\r\n\r\n        let s = this.scroller.style;\r\n        let cc = this.colors;\r\n\r\n        switch(mode){\r\n            case 0: // base\r\n                s.background = cc.text;\r\n            break;\r\n            case 1: // over\r\n                s.background = cc.select;\r\n            break;\r\n            case 2: // edit / down\r\n                s.background = cc.select;\r\n            break;\r\n\r\n        }\r\n\r\n        this.sMode = mode;\r\n    }\r\n\r\n    modeTitle ( mode ) {\r\n\r\n        if( mode === this.tMode ) return;\r\n\r\n        let s = this.s;\r\n        let cc = this.colors;\r\n\r\n        switch(mode){\r\n            case 0: // base\r\n                s[3].color = cc.text;\r\n                s[3].background = cc.button;\r\n            break;\r\n            case 1: // over\r\n                s[3].color = cc.textOver;\r\n                s[3].background = cc.overoff;\r\n            break;\r\n            case 2: // edit / down\r\n                s[3].color = cc.textSelect;\r\n                s[3].background = cc.overoff;\r\n            break;\r\n\r\n        }\r\n\r\n        this.tMode = mode;\r\n\r\n    }\r\n\r\n    clearList () {\r\n\r\n        while ( this.listIn.children.length ) this.listIn.removeChild( this.listIn.lastChild );\r\n        this.items = [];\r\n\r\n    }\r\n\r\n    setList ( list ) {\r\n\r\n        this.clearList();\r\n\r\n        this.list = list;\r\n        this.length = this.list.length;\r\n\r\n        this.maxItem = this.full ? this.length : 5;\r\n        this.maxItem = this.length < this.maxItem ? this.length : this.maxItem;\r\n\r\n        this.maxHeight = this.maxItem * (this.itemHeight+1) + 2;\r\n\r\n        this.max = this.length * (this.itemHeight+1) + 2;\r\n        this.ratio = this.maxHeight / this.max;\r\n        this.sh = this.maxHeight * this.ratio;\r\n        this.range = this.maxHeight - this.sh;\r\n\r\n        this.c[2].style.height = this.maxHeight + 'px';\r\n        this.scrollerBack.style.height = this.maxHeight + 'px';\r\n        this.scroller.style.height = this.sh + 'px';\r\n\r\n        if( this.max > this.maxHeight ){ \r\n            this.ww = this.sb - this.ss;\r\n            this.scroll = true;\r\n        }\r\n\r\n        if( this.miniCanvas ) {\r\n\r\n            this.tmpCanvas = document.createElement('canvas');\r\n            this.tmpCanvas.width = this.imageSize[0];\r\n            this.tmpCanvas.height = this.imageSize[1];\r\n            this.tmpCtx = this.tmpCanvas.getContext(\"2d\");\r\n            this.tmpCtx.fillStyle = this.canvasBg;\r\n            this.tmpCtx.fillRect(0, 0, this.imageSize[0], this.imageSize[1]);\r\n\r\n        }\r\n\r\n        let item, n;//, l = this.sb;\r\n        for( let i=0; i<this.length; i++ ){\r\n\r\n            n = this.list[i];\r\n            item = this.dom( 'div', this.css.item + 'width:'+this.ww+'px; height:'+this.itemHeight+'px; line-height:'+(this.itemHeight-5)+'px; color:'+this.colors.text+'; background:'+this.colors.back+';' );\r\n            item.name = 'item'+i;\r\n            item.id = i;\r\n            item.select = false;\r\n            item.posy = (this.itemHeight+1)*i;\r\n            this.listIn.appendChild( item );\r\n            this.items.push( item );\r\n\r\n            if( n === this.value ) this.current = item;\r\n\r\n            //if( this.isWithImage ) item.appendChild( this.tmpImage[n] );\r\n            if( !this.isWithImage ) item.textContent = n;\r\n\r\n            if( this.miniCanvas ){\r\n\r\n                let c = new Image();\r\n                c.src = this.tmpCanvas.toDataURL();\r\n\r\n\r\n                /*let c = document.createElement('canvas')\r\n\r\n                c.width = this.imageSize[0]\r\n                c.height = this.imageSize[1]\r\n                let ctx = c.getContext(\"2d\")\r\n                ctx.fillStyle = this.canvasBg\r\n                ctx.fillRect(0, 0, this.imageSize[0], this.imageSize[1])*/\r\n                c.style.cssText = 'position:relative; pointer-events:none; display:inline-block; float:left; margin-left:0px; margin-right:5px; top:2px';\r\n\r\n\r\n                //c.style.cssText = 'display:flex; align-content: flex-start; flex-wrap: wrap;'\r\n                //item.style.float = 'right'\r\n                item.appendChild( c );\r\n\r\n                this.tmpImage[n] = c;\r\n\r\n            }\r\n\r\n            if(this.dragout){\r\n\r\n                item.img = this.tmpImage[n];\r\n\r\n                item.style.pointerEvents = 'auto';\r\n                item.draggable=\"true\";\r\n\r\n                item.addEventListener('dragstart', this.dragstart || function(){ /*console.log('drag start')*/});\r\n                item.addEventListener('drag', this.drag || function(){ /*console.log('drag start')*/});\r\n                //item.addEventListener('dragover', this);\r\n                //item.addEventListener('dragenter', this);\r\n                item.addEventListener('dragleave', function(){ Roots.fakeUp(); } );\r\n                item.addEventListener('dragend', this.dragend || function(){ /*console.log('drag end')*/ }.bind(this) );\r\n                //item.addEventListener('drop', function(){console.log('drop')})\r\n\r\n            }\r\n\r\n        }\r\n\r\n        this.setTopItem();\r\n        if( this.isSelectable ) this.selected();\r\n        \r\n    }\r\n\r\n    drawImage( name, image, x,y,w,h ){\r\n        this.tmpCtx.clearRect(0, 0, this.imageSize[0], this.imageSize[1]);\r\n        this.tmpCtx.drawImage(image, x, y, w, h, 0, 0, this.imageSize[0], this.imageSize[1]);\r\n        this.tmpImage[name].src = this.tmpCanvas.toDataURL();\r\n\r\n\r\n        /*let c = this.tmpImage[name]\r\n        let ctx = c.getContext(\"2d\")\r\n        ctx.drawImage(image, x, y, w, h, 0, 0, this.imageSize[0], this.imageSize[1])*/\r\n\r\n    }\r\n\r\n    addImages (){\r\n        let lng = this.list.length;\r\n        for( let i=0; i<lng; i++ ){\r\n            this.items[i].appendChild( this.tmpImage[this.list[i]] );\r\n        }\r\n        this.setTopItem();\r\n    }\r\n\r\n    setValue ( value ) {\r\n\r\n        if(!isNaN(value)) this.value = this.list[ value ];\r\n        else this.value = value;\r\n\r\n        this.setTopItem();\r\n\r\n    }\r\n\r\n    setTopItem (){\r\n\r\n        if(this.staticTop) return;\r\n\r\n        if( this.isWithImage ){ \r\n\r\n            if( !this.preLoadComplete ) return;\r\n\r\n            if(!this.c[3].children.length){\r\n                this.canvas = document.createElement('canvas');\r\n                this.canvas.width = this.imageSize[0];\r\n                this.canvas.height = this.imageSize[1];\r\n                this.canvas.style.cssText = 'position:absolute; top:0px; left:0px;';\r\n                this.ctx = this.canvas.getContext(\"2d\");\r\n                this.c[3].appendChild( this.canvas );\r\n            }\r\n\r\n            this.tmpImage[ this.value ];\r\n            this.ctx.drawImage( this.tmpImage[ this.value ], 0, 0, this.imageSize[2], this.imageSize[3], 0,0, this.imageSize[0], this.imageSize[1] );\r\n\r\n        }\r\n        else this.c[3].textContent = this.value;\r\n\r\n\r\n        if( this.miniCanvas ){\r\n\r\n            if(!this.c[3].children.length){\r\n                this.canvas = document.createElement('canvas');\r\n                this.canvas.width = this.imageSize[0];\r\n                this.canvas.height = this.imageSize[1];\r\n                ( this.h - this.imageSize[1] ) * 0.5;\r\n                this.canvas.style.cssText = 'position:relative; pointer-events:none; display:inline-block; float:left; margin-left:0px; margin-right:5px; top:2px';\r\n                //this.canvas.style.cssText = 'position:absolute; top:'+h+'px; left:5px;'\r\n                this.ctx = this.canvas.getContext(\"2d\");\r\n                this.c[3].style.textAlign = 'left';\r\n                this.c[3].appendChild( this.canvas );\r\n\r\n            }\r\n\r\n            this.ctx.drawImage( this.tmpImage[ this.value ], 0, 0 );\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    // ----- LIST\r\n\r\n    update ( y ) {\r\n\r\n        if( !this.scroll ) return;\r\n\r\n        y = y < 0 ? 0 : y;\r\n        y = y > this.range ? this.range : y;\r\n\r\n        this.topList = -Math.floor( y / this.ratio );\r\n\r\n        this.listIn.style.top = this.topList+'px';\r\n        this.scroller.style.top = Math.floor( y )  + 'px';\r\n\r\n        this.py = y;\r\n\r\n    }\r\n\r\n    parentHeight ( t ) {\r\n\r\n        if ( this.group !== null ) this.group.calc( t );\r\n        else if ( this.isUI ) this.main.calc( t );\r\n\r\n    }\r\n\r\n    open ( first ) {\r\n\r\n        super.open();\r\n\r\n        this.update( 0 );\r\n\r\n        this.h = this.maxHeight + this.baseH + 5;\r\n        if( !this.scroll ){\r\n            this.topList = 0;\r\n            this.h = this.baseH + 5 + this.max;\r\n            this.scroller.style.display = 'none';\r\n            this.scrollerBack.style.display = 'none';\r\n        } else {\r\n            this.scroller.style.display = 'block';\r\n            this.scrollerBack.style.display = 'block';\r\n        }\r\n        this.s[0].height = this.h + 'px';\r\n        this.s[2].display = 'block';\r\n\r\n        if( this.up ){ \r\n            this.zone.y -= this.h - (this.baseH-10);\r\n            this.setSvg( this.c[4], 'd', this.svgs.arrowUp );\r\n        } else {\r\n            this.setSvg( this.c[4], 'd', this.svgs.arrowDown );\r\n        }\r\n\r\n        this.rSizeContent();\r\n\r\n        let t = this.h - this.baseH;\r\n\r\n        this.zone.h = this.h;\r\n\r\n        if(!first) this.parentHeight( t );\r\n\r\n    }\r\n\r\n    close () {\r\n\r\n        super.close();\r\n\r\n        if( this.up ) this.zone.y += this.h - (this.baseH-10);\r\n\r\n        let t = this.h - this.baseH;\r\n\r\n        this.h = this.baseH;\r\n        this.s[0].height = this.h + 'px';\r\n        this.s[2].display = 'none';\r\n        this.setSvg( this.c[4], 'd', this.svgs.arrow );\r\n\r\n        this.zone.h = this.h;\r\n\r\n        this.parentHeight( -t );\r\n\r\n    }\r\n\r\n    // -----\r\n\r\n    text ( txt ) {\r\n\r\n        this.c[3].textContent = txt;\r\n\r\n    }\r\n\r\n    rSizeContent () {\r\n\r\n        let i = this.length;\r\n        while(i--) this.listIn.children[i].style.width = this.ww + 'px';\r\n\r\n    }\r\n\r\n    rSize () {\r\n\r\n        super.rSize();\r\n\r\n        //Proto.prototype.rSize.call( this );\r\n\r\n        let s = this.s;\r\n        let w = this.sb;\r\n        let d = this.sa;\r\n\r\n        if(s[2]=== undefined) return;\r\n\r\n        s[2].width = w + 'px';\r\n        s[2].left = d +'px';\r\n\r\n        s[3].width = w + 'px';\r\n        s[3].left = d + 'px';\r\n\r\n        s[4].left = d + w - 17 + 'px';\r\n\r\n        this.ww = w;\r\n        if( this.max > this.maxHeight ) this.ww = w-this.ss;\r\n        if(this.isOpen) this.rSizeContent();\r\n\r\n    }\r\n\r\n}\n\nclass Numeric extends Proto {\r\n\r\n    constructor( o = {} ) {\r\n\r\n        super( o );\r\n\r\n        this.setTypeNumber( o );\r\n\r\n        this.allway = o.allway || false;\r\n\r\n        this.isDown = false;\r\n\r\n        this.value = [0];\r\n        this.multy = 1;\r\n        this.invmulty = 1;\r\n        this.isSingle = true;\r\n        this.isAngle = false;\r\n        this.isVector = false;\r\n\r\n        if( o.isAngle ){\r\n            this.isAngle = true;\r\n            this.multy = Tools.torad;\r\n            this.invmulty = Tools.todeg;\r\n        }\r\n\r\n        this.isDrag = o.drag || false;\r\n\r\n        if( o.value !== undefined ){\r\n            if(!isNaN(o.value)){ \r\n                this.value = [o.value];\r\n            } else if( o.value instanceof Array ){ \r\n                this.value = o.value; \r\n                this.isSingle = false;\r\n            } else if( o.value instanceof Object ){ \r\n                this.value = [];\r\n                if( o.value.x !== undefined ) this.value[0] = o.value.x;\r\n                if( o.value.y !== undefined ) this.value[1] = o.value.y;\r\n                if( o.value.z !== undefined ) this.value[2] = o.value.z;\r\n                if( o.value.w !== undefined ) this.value[3] = o.value.w;\r\n                this.isVector = true;\r\n                this.isSingle = false;\r\n            }\r\n        }\r\n\r\n        this.lng = this.value.length;\r\n        this.tmp = [];\r\n\r\n        \r\n\r\n        this.current = -1;\r\n        this.prev = { x:0, y:0, d:0, v:0 };\r\n\r\n        let cc = this.colors;\r\n\r\n        // bg\r\n        this.c[2] = this.dom( 'div', this.css.basic + ' background:' + cc.select + '; top:4px; width:0px; height:' + (this.h-8) + 'px;' );\r\n\r\n        this.cMode = [];\r\n        \r\n        let i = this.lng;\r\n        while(i--){\r\n\r\n            if(this.isAngle) this.value[i] = (this.value[i] * 180 / Math.PI).toFixed( this.precision );\r\n            this.c[3+i] = this.dom( 'div', this.css.txtselect + ' height:'+(this.h-4)+'px; color:' + cc.text + '; background:' + cc.back + '; borderColor:' + cc.border+'; border-radius:'+this.radius+'px;');\r\n            if(o.center) this.c[2+i].style.textAlign = 'center';\r\n            this.c[3+i].textContent = this.value[i];\r\n            this.c[3+i].style.color = this.colors.text;\r\n            this.c[3+i].isNum = true;\r\n\r\n            this.cMode[i] = 0;\r\n\r\n        }\r\n\r\n        // selection\r\n        this.selectId = 3 + this.lng;\r\n        this.c[this.selectId] = this.dom(  'div', this.css.txtselect + 'position:absolute; top:4px; height:' + (this.h-8) + 'px; padding:0px 0px; width:0px; color:' + cc.textSelect + '; background:' + cc.select + '; border:none; border-radius:0px;');\r\n\r\n        // cursor\r\n        this.cursorId = 4 + this.lng;\r\n        this.c[ this.cursorId ] = this.dom( 'div', this.css.basic + 'top:4px; height:' + (this.h-8) + 'px; width:0px; background:'+cc.text+';' );\r\n\r\n        this.init();\r\n    }\r\n\r\n    testZone ( e ) {\r\n\r\n        let l = this.local;\r\n        if( l.x === -1 && l.y === -1 ) return '';\r\n\r\n        let i = this.lng;\r\n        let t = this.tmp;\r\n        \r\n\r\n        while( i-- ){\r\n            if( l.x>t[i][0] && l.x<t[i][2] ) return i;\r\n        }\r\n\r\n        return '';\r\n\r\n    }\r\n\r\n   /* mode: function ( n, name ) {\r\n\r\n        if( n === this.cMode[name] ) return false;\r\n\r\n        //let m;\r\n\r\n        /*switch(n){\r\n\r\n            case 0: m = this.colors.border; break;\r\n            case 1: m = this.colors.borderOver; break;\r\n            case 2: m = this.colors.borderSelect;  break;\r\n\r\n        }*/\r\n\r\n   /*     this.reset();\r\n        //this.c[name+2].style.borderColor = m;\r\n        this.cMode[name] = n;\r\n\r\n        return true;\r\n\r\n    },*/\r\n\r\n    // ----------------------\r\n    //   EVENTS\r\n    // ----------------------\r\n\r\n    mousedown ( e ) {\r\n\r\n        let name = this.testZone( e );\r\n\r\n        if( !this.isDown ){\r\n            this.isDown = true;\r\n            if( name !== '' ){ \r\n            \tthis.current = name;\r\n            \tthis.prev = { x:e.clientX, y:e.clientY, d:0, v: this.isSingle ? parseFloat(this.value) : parseFloat( this.value[ this.current ] )  };\r\n            \tthis.setInput( this.c[ 3 + this.current ] );\r\n            }\r\n            return this.mousemove( e );\r\n        }\r\n\r\n        return false;\r\n        /*\r\n\r\n        if( name === '' ) return false;\r\n\r\n\r\n        this.current = name;\r\n        this.isDown = true;\r\n\r\n        this.prev = { x:e.clientX, y:e.clientY, d:0, v: this.isSingle ? parseFloat(this.value) : parseFloat( this.value[ this.current ] )  };\r\n\r\n\r\n        return this.mode( 2, name );*/\r\n\r\n    }\r\n\r\n    mouseup ( e ) {\r\n\r\n    \tif( this.isDown ){\r\n            \r\n            this.isDown = false;\r\n            //this.current = -1;\r\n            this.prev = { x:0, y:0, d:0, v:0 };\r\n\r\n            return this.mousemove( e );\r\n        }\r\n\r\n        return false;\r\n\r\n        /*let name = this.testZone( e );\r\n        this.isDown = false;\r\n\r\n        if( this.current !== -1 ){ \r\n\r\n            //let tm = this.current;\r\n            let td = this.prev.d;\r\n\r\n            this.current = -1;\r\n            this.prev = { x:0, y:0, d:0, v:0 };\r\n\r\n            if( !td ){\r\n\r\n                this.setInput( this.c[ 3 + name ] );\r\n                return true;//this.mode( 2, name );\r\n\r\n            } else {\r\n                return this.reset();//this.mode( 0, tm );\r\n            }\r\n\r\n        }*/\r\n\r\n    }\r\n\r\n    mousemove ( e ) {\r\n\r\n        let nup = false;\r\n        let x = 0;\r\n\r\n        let name = this.testZone( e );\r\n\r\n        if( name === '' ) this.cursor();\r\n        else { \r\n        \tif(!this.isDrag) this.cursor('text');\r\n        \telse this.cursor( this.current !== -1 ? 'move' : 'pointer' );\r\n        }\r\n\r\n        \r\n\r\n        if( this.isDrag ){\r\n\r\n        \tif( this.current !== -1 ){\r\n\r\n            \tthis.prev.d += ( e.clientX - this.prev.x ) - ( e.clientY - this.prev.y );\r\n\r\n                let n = this.prev.v + ( this.prev.d * this.step);\r\n\r\n                this.value[ this.current ] = this.numValue(n);\r\n                this.c[ 3 + this.current ].textContent = this.value[this.current];\r\n\r\n                this.validate();\r\n\r\n                this.prev.x = e.clientX;\r\n                this.prev.y = e.clientY;\r\n\r\n                nup = true;\r\n             }\r\n\r\n        } else {\r\n\r\n        \tif( this.isDown ) x = e.clientX - this.zone.x -3;\r\n        \tif( this.current !== -1 ) x -= this.tmp[this.current][0];\r\n        \treturn this.upInput( x, this.isDown );\r\n\r\n        }\r\n\r\n        \r\n\r\n\r\n        return nup;\r\n\r\n    }\r\n\r\n    //keydown: function ( e ) { return true; },\r\n\r\n    // ----------------------\r\n\r\n    reset () {\r\n\r\n        let nup = false;\r\n        //this.isDown = false;\r\n\r\n        //this.current = 0;\r\n\r\n       /* let i = this.lng;\r\n        while(i--){ \r\n            if(this.cMode[i]!==0){\r\n                this.cMode[i] = 0;\r\n                //this.c[2+i].style.borderColor = this.colors.border;\r\n                nup = true;\r\n            }\r\n        }*/\r\n\r\n        return nup;\r\n\r\n    }\r\n\r\n\r\n    setValue ( v ) {\r\n\r\n        if( this.isVector ){\r\n\r\n            if( v.x !== undefined ) this.value[0] = v.x;\r\n            if( v.y !== undefined ) this.value[1] = v.y;\r\n            if( v.z !== undefined ) this.value[2] = v.z;\r\n            if( v.w !== undefined ) this.value[3] = v.w;\r\n\r\n        } else {\r\n\r\n            if( this.isSingle ) this.value = [v];\r\n            else this.value = v;\r\n            \r\n        }\r\n\r\n        this.update();\r\n\r\n    }\r\n\r\n    sameStr ( str ){\r\n\r\n        let i = this.value.length;\r\n        while(i--) this.c[ 3 + i ].textContent = str;\r\n\r\n    }\r\n\r\n    update ( up ) {\r\n\r\n        let i = this.value.length;\r\n\r\n        while(i--){\r\n             this.value[i] = this.numValue( this.value[i] * this.invmulty );\r\n             this.c[ 3 + i ].textContent = this.value[i];\r\n        }\r\n\r\n        if( up ) this.send();\r\n\r\n    }\r\n\r\n    send ( v ) {\r\n\r\n        v = v || this.value;\r\n\r\n        this.isSend = true;\r\n\r\n        if( this.objectLink !== null ){ \r\n\r\n            if( this.isVector ){\r\n\r\n                this.objectLink[ this.val ].fromArray( v );\r\n\r\n                /*this.objectLink[ this.val ].x = v[0];\r\n                this.objectLink[ this.val ].y = v[1];\r\n                this.objectLink[ this.val ].z = v[2];\r\n                if( v[3] ) this.objectLink[ this.val ].w = v[3];*/\r\n\r\n            } else {\r\n                this.objectLink[ this.val ] = v;\r\n            }\r\n\r\n        }\r\n\r\n        if( this.callback ) this.callback( v, this.val );\r\n\r\n        this.isSend = false;\r\n\r\n    }\r\n\r\n\r\n    // ----------------------\r\n    //   INPUT\r\n    // ----------------------\r\n\r\n    select ( c, e, w, t ) {\r\n\r\n        let s = this.s;\r\n        let d = this.current !== -1 ? this.tmp[this.current][0] + 5 : 0;\r\n        s[this.cursorId].width = '1px';\r\n        s[this.cursorId].left = ( d + c ) + 'px';\r\n        //s[2].left = ( d + e ) + 'px';\r\n        //s[2].width = w + 'px';\r\n\r\n        s[this.selectId].left =  ( d + e )  + 'px';\r\n        s[this.selectId].width =  w  + 'px';\r\n        this.c[this.selectId].innerHTML = t;\r\n    \r\n    }\r\n\r\n    unselect () {\r\n\r\n        let s = this.s;\r\n        if(!s) return;\r\n        this.c[this.selectId].innerHTML = '';\r\n        s[this.selectId].width = 0 + 'px';\r\n        s[this.cursorId].width = 0 + 'px';\r\n\r\n    }\r\n\r\n    validate ( force ) {\r\n\r\n        let ar = [];\r\n        let i = this.lng;\r\n\r\n        if( this.allway ) force = true;\r\n\r\n        while(i--){\r\n        \tif(!isNaN( this.c[ 3 + i ].textContent )){ \r\n                let nx = this.numValue( this.c[ 3 + i ].textContent );\r\n                this.c[ 3 + i ].textContent = nx;\r\n                this.value[i] = nx;\r\n            } else { // not number\r\n                this.c[ 3 + i ].textContent = this.value[i];\r\n            }\r\n\r\n        \tar[i] = this.value[i] * this.multy;\r\n        }\r\n\r\n        if( !force ) return;\r\n\r\n        if( this.isSingle ) this.send( ar[0] );\r\n        else this.send( ar );\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   REZISE\r\n    // ----------------------\r\n\r\n    rSize () {\r\n\r\n        super.rSize();\r\n\r\n        let w = Math.floor( ( this.sb + 5 ) / this.lng )-5;\r\n        let s = this.s;\r\n        let i = this.lng;\r\n        while(i--){\r\n            this.tmp[i] = [ Math.floor( this.sa + ( w * i )+( 5 * i )), w ];\r\n            this.tmp[i][2] = this.tmp[i][0] + this.tmp[i][1];\r\n            s[ 3 + i ].left = this.tmp[i][0] + 'px';\r\n            s[ 3 + i ].width = this.tmp[i][1] + 'px';\r\n        }\r\n\r\n    }\r\n\r\n}\n\nclass Slide extends Proto {\r\n\r\n    constructor( o = {} ) {\r\n\r\n        super( o );\r\n\r\n        this.setTypeNumber( o );\r\n\r\n\r\n        this.model = o.stype || 0;\r\n        if( o.mode !== undefined ) this.model = o.mode;\r\n\r\n        //this.defaultBorderColor = this.colors.hide;\r\n\r\n        this.isDown = false;\r\n        this.isOver = false;\r\n        this.allway = o.allway || false;\r\n\r\n        this.isDeg = o.isDeg || false;\r\n        this.isCyclic = o.cyclic || false;\r\n\r\n        this.firstImput = false;\r\n\r\n        let cc = this.colors;\r\n\r\n        //this.c[2] = this.dom( 'div', this.css.txtselect + 'letter-spacing:-1px; text-align:right; width:47px; border:1px dashed '+this.defaultBorderColor+'; color:'+ this.colors.text );\r\n        //this.c[2] = this.dom( 'div', this.css.txtselect + 'text-align:right; width:47px; border:1px dashed '+this.defaultBorderColor+'; color:'+ this.colors.text );\r\n        this.c[2] = this.dom( 'div', this.css.txtselect + 'border:none; background:none; width:47px; color:'+ cc.text +';' );\r\n        //this.c[2] = this.dom( 'div', this.css.txtselect + 'letter-spacing:-1px; text-align:right; width:47px; color:'+ this.colors.text );\r\n        this.c[3] = this.dom( 'div', this.css.basic + ' top:0; height:'+this.h+'px;' );\r\n        this.c[4] = this.dom( 'div', this.css.basic + 'background:'+cc.back+'; top:2px; height:'+(this.h-4)+'px;' );\r\n        this.c[5] = this.dom( 'div', this.css.basic + 'left:4px; top:5px; height:'+(this.h-10)+'px; background:' + cc.text +';' );\r\n\r\n        this.c[2].isNum = true;\r\n        //this.c[2].style.height = (this.h-4) + 'px';\r\n        //this.c[2].style.lineHeight = (this.h-8) + 'px';\r\n        this.c[2].style.height = (this.h-2) + 'px';\r\n        this.c[2].style.lineHeight = (this.h-10) + 'px';\r\n\r\n        if(this.model !== 0){\r\n\r\n            let h1 = 4, h2 = 8, ww = this.h-4, ra = 20;\r\n\r\n            if( this.model === 2 ){\r\n                h1 = 4;//2\r\n                h2 = 8;\r\n                ra = 2;\r\n                ww = (this.h-4)*0.5;\r\n            }\r\n\r\n            if(this.model === 3) this.c[5].style.visible = 'none';\r\n\r\n            this.c[4].style.borderRadius = h1 + 'px';\r\n            this.c[4].style.height = h2 + 'px';\r\n            this.c[4].style.top = (this.h*0.5) - h1 + 'px';\r\n            this.c[5].style.borderRadius = (h1*0.5) + 'px';\r\n            this.c[5].style.height = h1 + 'px';\r\n            this.c[5].style.top = (this.h*0.5)-(h1*0.5) + 'px';\r\n\r\n            this.c[6] = this.dom( 'div', this.css.basic + 'border-radius:'+ra+'px; margin-left:'+(-ww*0.5)+'px; border:1px solid '+cc.border+'; background:'+cc.button+'; left:4px; top:2px; height:'+(this.h-4)+'px; width:'+ww+'px;' );\r\n        }\r\n\r\n        this.init();\r\n\r\n    }\r\n\r\n    testZone ( e ) {\r\n\r\n        let l = this.local;\r\n        if( l.x === -1 && l.y === -1 ) return '';\r\n        \r\n        if( l.x >= this.txl ) return 'text';\r\n        else if( l.x >= this.sa ) return 'scroll';\r\n        else return '';\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   EVENTS\r\n    // ----------------------\r\n\r\n    mouseup ( e ) {\r\n        \r\n        if( this.isDown ) this.isDown = false;\r\n        \r\n    }\r\n\r\n    mousedown ( e ) {\r\n\r\n        let name = this.testZone( e );\r\n\r\n        if( !name ) return false;\r\n\r\n        if( name === 'scroll' ){ \r\n            this.isDown = true;\r\n            this.old = this.value;\r\n            this.mousemove( e );\r\n            \r\n        }\r\n\r\n        /*if( name === 'text' ){\r\n            this.setInput( this.c[2], function(){ this.validate() }.bind(this) );\r\n        }*/\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n    mousemove ( e ) {\r\n\r\n        let nup = false;\r\n\r\n        let name = this.testZone( e );\r\n\r\n        if( name === 'scroll' ) {\r\n            this.mode(1);\r\n            this.cursor('w-resize');\r\n        //} else if(name === 'text'){ \r\n            //this.cursor('pointer');\r\n        } else {\r\n            this.cursor();\r\n        }\r\n\r\n        if( this.isDown ){\r\n\r\n            let n = ((( e.clientX - (this.zone.x+this.sa) - 3 ) / this.ww ) * this.range + this.min ) - this.old;\r\n            if(n >= this.step || n <= this.step){ \r\n                n = Math.floor( n / this.step );\r\n                this.value = this.numValue( this.old + ( n * this.step ) );\r\n                this.update( true );\r\n                this.old = this.value;\r\n            }\r\n            nup = true;\r\n        }\r\n\r\n        return nup;\r\n\r\n    }\r\n\r\n    wheel ( e ) {\r\n\r\n        let name = this.testZone( e );\r\n    \r\n        if( name === 'scroll' ) {\r\n    \r\n            let v = this.value - this.step * e.delta;\r\n    \r\n            if ( v > this.max ) {\r\n                v = this.isCyclic ? this.min : this.max;\r\n            } else if ( v < this.min ) {\r\n                v = this.isCyclic ? this.max : this.min;\r\n            }\r\n    \r\n            this.setValue(v);\r\n            this.old = v;\r\n            this.update( true );\r\n\r\n            return true;\r\n    \r\n        }\r\n              \r\n        return false;\r\n    \r\n    }\r\n\r\n    //keydown: function ( e ) { return true; },\r\n\r\n    // ----------------------\r\n\r\n    validate () {\r\n        \r\n        let n = this.c[2].textContent;\r\n\r\n        if(!isNaN( n )){ \r\n            this.value = this.numValue( n ); \r\n            this.update(true); \r\n        }\r\n\r\n        else this.c[2].textContent = this.value + (this.isDeg ? '°':'');\r\n\r\n    }\r\n\r\n\r\n    reset () {\r\n\r\n        //this.clearInput();\r\n        this.isDown = false;\r\n        this.mode(0);\r\n\r\n    }\r\n\r\n    mode ( mode ) {\r\n\r\n        let s = this.s;\r\n        let cc = this.colors;\r\n\r\n        switch(mode){\r\n            case 0: // base\r\n               // s[2].border = '1px solid ' + this.colors.hide;\r\n                s[2].color = cc.text;\r\n                s[4].background = cc.back;\r\n                s[5].background = cc.text;\r\n            break;\r\n            case 1: // scroll over\r\n                //s[2].border = '1px dashed ' + this.colors.hide;\r\n                s[2].color = cc.textOver;\r\n                s[4].background = cc.back;\r\n                s[5].background = cc.textOver;\r\n            break;\r\n           /* case 2: \r\n                s[2].border = '1px solid ' + this.colors.borderSelect;\r\n            break;\r\n            case 3: \r\n                s[2].border = '1px dashed ' + this.colors.text;//this.colors.borderSelect;\r\n            break;\r\n            case 4: \r\n                s[2].border = '1px dashed ' + this.colors.hide;\r\n            break;*/\r\n\r\n\r\n        }\r\n    }\r\n\r\n    update ( up ) {\r\n\r\n        let ww = Math.floor( this.ww * (( this.value - this.min ) / this.range ));\r\n       \r\n        if(this.model !== 3) this.s[5].width = ww + 'px';\r\n        if(this.s[6]) this.s[6].left = ( this.sa + ww + 3 ) + 'px';\r\n        this.c[2].textContent = this.value + (this.isDeg ? '°':'');\r\n\r\n        if( up ) this.send();\r\n\r\n    }\r\n\r\n    rSize () {\r\n\r\n        super.rSize();\r\n\r\n        let w = this.sb - this.sc;\r\n        this.ww = w - 6;\r\n\r\n        let tx = this.sc;\r\n        if(this.isUI || !this.simple) tx = this.sc+10;\r\n        this.txl = this.w - tx + 2;\r\n\r\n        //let ty = Math.floor(this.h * 0.5) - 8;\r\n\r\n        let s = this.s;\r\n\r\n        s[2].width = (this.sc -6 )+ 'px';\r\n        s[2].left = (this.txl +4) + 'px';\r\n        //s[2].top = ty + 'px';\r\n        s[3].left = this.sa + 'px';\r\n        s[3].width = w + 'px';\r\n        s[4].left = this.sa + 'px';\r\n        s[4].width = w + 'px';\r\n        s[5].left = (this.sa + 3) + 'px';\r\n\r\n        this.update();\r\n\r\n    }\r\n\r\n}\n\nclass TextInput extends Proto {\r\n\r\n    constructor( o = {} ) {\r\n\r\n        super( o );\r\n\r\n        this.cmode = 0;\r\n\r\n        this.value = o.value || '';\r\n        this.placeHolder = o.placeHolder || '';\r\n\r\n        this.allway = o.allway || false;\r\n        this.editable = o.edit !== undefined ? o.edit : true;\r\n\r\n        this.isDown = false;\r\n\r\n        let cc = this.colors;\r\n\r\n        // text\r\n        this.c[2] = this.dom( 'div', this.css.txtselect + 'height:' + (this.h-4) + 'px; color:' + cc.text + '; background:' + cc.back + '; borderColor:' + cc.border+'; border-radius:'+this.radius+'px;' );\r\n        this.c[2].textContent = this.value;\r\n\r\n        // selection\r\n        this.c[3] = this.dom(  'div', this.css.txtselect + 'position:absolute; top:4px; height:' + (this.h-8) + 'px; padding:0px 0px; width:0px; color:' + cc.textSelect + '; background:' + cc.select + '; border:none; border-radius:0px;');\r\n\r\n        // cursor\r\n        this.c[4] = this.dom( 'div', this.css.basic + 'top:4px; height:' + (this.h-8) + 'px; width:0px; background:'+cc.text+';' );\r\n\r\n        // fake\r\n        this.c[5] = this.dom( 'div', this.css.txtselect + 'height:' + (this.h-4) + 'px; justify-content: center; font-style: italic; color:'+cc.border+';' );\r\n        if( this.value === '' ) this.c[5].textContent = this.placeHolder;\r\n\r\n        \r\n\r\n\r\n        this.init();\r\n\r\n    }\r\n\r\n    testZone ( e ) {\r\n\r\n        let l = this.local;\r\n        if( l.x === -1 && l.y === -1 ) return '';\r\n        if( l.x >= this.sa ) return 'text';\r\n        return '';\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   EVENTS\r\n    // ----------------------\r\n\r\n    mouseup ( e ) {\r\n\r\n        if(!this.editable) return;\r\n\r\n        if( this.isDown ){\r\n            this.isDown = false;\r\n            return this.mousemove( e );\r\n        }\r\n\r\n        return false;\r\n\r\n    }\r\n\r\n    mousedown ( e ) {\r\n\r\n        if(!this.editable) return;\r\n\r\n        let name = this.testZone( e );\r\n\r\n        if( !this.isDown ){\r\n            this.isDown = true;\r\n            if( name === 'text' ) this.setInput( this.c[2] );\r\n            return this.mousemove( e );\r\n        }\r\n\r\n        return false;\r\n\r\n    }\r\n\r\n    mousemove ( e ) {\r\n\r\n        if(!this.editable) return;\r\n\r\n        let name = this.testZone( e );\r\n\r\n        //let l = this.local;\r\n        //if( l.x === -1 && l.y === -1 ){ return;}\r\n\r\n        //if( l.x >= this.sa ) this.cursor('text');\r\n        //else this.cursor();\r\n\r\n        let x = 0;\r\n\r\n        if( name === 'text' ) this.cursor('text');\r\n        else this.cursor();\r\n\r\n        if( this.isDown ) x = e.clientX - this.zone.x;\r\n\r\n        return this.upInput( x - this.sa -3, this.isDown );\r\n\r\n    }\r\n\r\n    update ( ) {\r\n\r\n        this.c[2].textContent = this.value;\r\n        \r\n    }\r\n\r\n    // ----------------------\r\n\r\n    reset () {\r\n\r\n        this.cursor();\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   INPUT\r\n    // ----------------------\r\n\r\n    select ( c, e, w, t ) {\r\n\r\n        let s = this.s;\r\n        let d = this.sa + 5;\r\n        s[4].width = '1px';\r\n        s[4].left = ( d + e ) + 'px';\r\n\r\n        s[3].left =  ( d + e )  + 'px';\r\n        s[3].width =  w  + 'px';\r\n        this.c[3].innerHTML = t;\r\n    \r\n    }\r\n\r\n    unselect () {\r\n\r\n        let s = this.s;\r\n        if(!s) return;\r\n        s[3].width =  0  + 'px';\r\n        this.c[3].innerHTML = 't';\r\n        s[4].width = 0 + 'px';\r\n\r\n    }\r\n\r\n    validate ( force ) {\r\n\r\n        if( this.allway ) force = true; \r\n\r\n        this.value = this.c[2].textContent;\r\n\r\n        if(this.value !== '') this.c[5].textContent = '';\r\n        else this.c[5].textContent = this.placeHolder;\r\n\r\n        if( !force ) return;\r\n\r\n        this.send();\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   REZISE\r\n    // ----------------------\r\n\r\n    rSize () {\r\n\r\n        super.rSize();\r\n\r\n        let s = this.s;\r\n        s[2].left = this.sa + 'px';\r\n        s[2].width = this.sb + 'px';\r\n\r\n        s[5].left = this.sa + 'px';\r\n        s[5].width = this.sb + 'px';\r\n     \r\n    }\r\n\r\n\r\n}\n\nclass Title extends Proto {\r\n\r\n    constructor( o = {} ) {\r\n\r\n        super( o );\r\n\r\n        let prefix = o.prefix || '';\r\n\r\n        this.c[2] = this.dom( 'div', this.css.txt + 'justify-content:right; width:60px; line-height:'+ (this.h-8) + 'px; color:' + this.colors.text );\r\n\r\n        if( this.h === 31 ){\r\n\r\n            this.s[0].height = this.h + 'px';\r\n            this.s[1].top = 8 + 'px';\r\n            this.c[2].style.top = 8 + 'px';\r\n\r\n        }\r\n\r\n        let s = this.s;\r\n\r\n        s[1].justifyContent = o.align || 'left';\r\n        //s[1].textAlign = o.align || 'left';\r\n        s[1].fontWeight = o.fontWeight || 'bold';\r\n\r\n\r\n        this.c[1].textContent = this.txt.substring(0,1).toUpperCase() + this.txt.substring(1).replace(\"-\", \" \");\r\n        this.c[2].textContent = prefix;\r\n\r\n        this.init();\r\n\r\n    }\r\n\r\n    text( txt ) {\r\n\r\n        this.c[1].textContent = txt;\r\n\r\n    }\r\n\r\n    text2( txt ) {\r\n\r\n        this.c[2].textContent = txt;\r\n\r\n    }\r\n\r\n    rSize() {\r\n\r\n        super.rSize();\r\n        this.s[1].width = this.w + 'px'; //- 50 + 'px';\r\n        this.s[2].left = this.w + 'px';//- ( 50 + 26 ) + 'px';\r\n\r\n    }\r\n\r\n    setColor( c ) {\r\n        this.s[1].color = c;\r\n        this.s[2].color = c;\r\n    }\r\n\r\n}\n\nclass Select extends Proto {\r\n\r\n    constructor( o = {} ) {\r\n\r\n        super( o );\r\n\r\n        this.value = o.value || '';\r\n\r\n        this.isDown = false;\r\n\r\n        this.onActif = o.onActif || function(){};\r\n\r\n        o.prefix || '';\r\n\r\n        this.c[2] = this.dom( 'div', this.css.txt + this.css.button + ' top:1px; background:'+this.colors.button+'; height:'+(this.h-2)+'px; border:'+this.colors.buttonBorder+'; border-radius:15px; width:30px; left:10px;' );\r\n        this.c[2].style.color = this.fontColor;\r\n\r\n        this.c[3] = this.dom( 'div', this.css.txtselect + 'height:' + (this.h-4) + 'px; background:' + this.colors.inputBg + '; borderColor:' + this.colors.inputBorder+'; border-radius:'+this.radius+'px;' );\r\n        this.c[3].textContent = this.value;\r\n\r\n        let fltop = Math.floor(this.h*0.5)-7;\r\n        this.c[4] = this.dom( 'path', this.css.basic + 'position:absolute; width:14px; height:14px; left:5px; top:'+fltop+'px;', { d:this.svgs[ 'cursor' ], fill:this.fontColor, stroke:'none'});\r\n\r\n        this.stat = 1;\r\n        this.isActif = false;\r\n\r\n        this.init();\r\n\r\n    }\r\n\r\n    testZone ( e ) {\r\n\r\n        let l = this.local;\r\n        if( l.x === -1 && l.y === -1 ) return '';\r\n        if( l.x > this.sa && l.x < this.sa+30 ) return 'over';\r\n        return '0'\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   EVENTS\r\n    // ----------------------\r\n\r\n    mouseup ( e ) {\r\n    \r\n        if( this.isDown ){\r\n            //this.value = false;\r\n            this.isDown = false;\r\n            //this.send();\r\n            return this.mousemove( e );\r\n        }\r\n\r\n        return false;\r\n\r\n    }\r\n\r\n    mousedown ( e ) {\r\n\r\n        let name = this.testZone( e );\r\n\r\n        if( !name ) return false;\r\n\r\n        this.isDown = true;\r\n        //this.value = this.values[ name-2 ];\r\n        //this.send();\r\n        return this.mousemove( e );\r\n\r\n    }\r\n\r\n    mousemove ( e ) {\r\n\r\n        let up = false;\r\n\r\n        let name = this.testZone( e );\r\n        //let sel = false;\r\n\r\n        \r\n\r\n        //console.log(name)\r\n\r\n        if( name === 'over' ){\r\n            this.cursor('pointer');\r\n            up = this.mode( this.isDown ? 3 : 2 );\r\n        } else {\r\n            up = this.reset();\r\n        }\r\n\r\n        return up;\r\n\r\n    }\r\n\r\n    // ----------------------\r\n\r\n    apply ( v ) {\r\n\r\n        v = v || '';\r\n\r\n        if( v !== this.value ) {\r\n            this.value = v;\r\n            this.c[3].textContent = this.value;\r\n            this.send();\r\n        }\r\n        \r\n        this.mode(1);\r\n\r\n    }\r\n\r\n    update () {\r\n\r\n        this.mode( 3 );\r\n\r\n    }\r\n\r\n    mode ( n ) {\r\n\r\n        let change = false;\r\n        let cc = this.colors;\r\n\r\n        if( this.stat !== n ){\r\n\r\n            if( n===1 ) this.isActif = false;\r\n            if( n===3 ){ \r\n                if( !this.isActif ){ this.isActif = true; n=4; this.onActif( this ); }\r\n                else { this.isActif = false; }\r\n            }\r\n\r\n            if( n===2 && this.isActif ) n = 4;\r\n\r\n            this.stat = n;\r\n\r\n            switch( n ){\r\n\r\n                case 1: this.s[ 2 ].color = cc.text; this.s[ 2 ].background = cc.button; break; // base\r\n                case 2: this.s[ 2 ].color = cc.textOver; this.s[ 2 ].background = cc.over; break; // over\r\n                case 3: this.s[ 2 ].color = cc.textSelect; this.s[ 2 ].background = cc.select; break; // down\r\n                case 4: this.s[ 2 ].color = cc.textSelect; this.s[ 2 ].background = cc.action; break; // actif\r\n\r\n            }\r\n\r\n            change = true;\r\n\r\n        }\r\n\r\n        return change;\r\n\r\n\r\n\r\n    }\r\n\r\n    reset () {\r\n\r\n        this.cursor();\r\n        return this.mode( this.isActif ? 4 : 1 );\r\n\r\n    }\r\n\r\n    text ( txt ) {\r\n\r\n        this.c[3].textContent = txt;\r\n\r\n    }\r\n\r\n    rSize () {\r\n\r\n        super.rSize();\r\n\r\n        let s = this.s;\r\n        s[2].left = this.sa + 'px';\r\n        s[3].left = (this.sa + 40) + 'px';\r\n        s[3].width = (this.sb - 40) + 'px';\r\n        s[4].left = (this.sa+8) + 'px';\r\n\r\n    }\r\n\r\n}\n\n//import { Proto } from '../core/Proto.js';\r\n\r\nclass Selector extends Button {\r\n\r\n    constructor( o = {} ) {\r\n\r\n        if( o.selectable === undefined ) o.selectable = true;\r\n        super( o );\r\n     \r\n    }\r\n\r\n}\n\nclass Empty extends Proto {\r\n\r\n    constructor( o = {} ) {\r\n\r\n\t    o.isSpace = true;\r\n        o.margin = 0;\r\n        if(!o.h) o.h = 10;\r\n        super( o );\r\n        this.init();\r\n\r\n    }\r\n    \r\n}\n\nclass Item extends Proto {\r\n\r\n    constructor( o = {} ) {\r\n\r\n        super( o );\r\n\r\n        this.p = 100;\r\n        this.value = this.txt;\r\n        this.status = 1;\r\n\r\n        this.itype = o.itype || 'none';\r\n        this.val = this.itype;\r\n\r\n        this.graph = this.svgs[ this.itype ];\r\n\r\n        let fltop = Math.floor(this.h*0.5)-7;\r\n\r\n        this.c[2] = this.dom( 'path', this.css.basic + 'position:absolute; width:14px; height:14px; left:5px; top:'+fltop+'px;', { d:this.graph, fill:this.colors.text, stroke:'none'});\r\n\r\n        this.s[1].marginLeft = 20 + 'px';\r\n\r\n        this.init();\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   EVENTS\r\n    // ----------------------\r\n\r\n    mousemove ( e ) {\r\n\r\n        this.cursor('pointer');\r\n\r\n        //up = this.modes( this.isDown ? 3 : 2, name );\r\n\r\n    }\r\n\r\n    mousedown ( e ) {\r\n\r\n        if( this.isUI ) this.main.resetItem();\r\n\r\n        this.selected( true );\r\n\r\n        this.send();\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n    uiout () {\r\n\r\n        if( this.isSelect ) this.mode(3);\r\n        else this.mode(1);\r\n\r\n    }\r\n\r\n    uiover () {\r\n\r\n        if( this.isSelect ) this.mode(4);\r\n        else this.mode(2);\r\n\r\n    }\r\n\r\n    update () {\r\n            \r\n    }\r\n\r\n    /*rSize () {\r\n        \r\n        super.rSize();\r\n\r\n    }*/\r\n\r\n    mode ( n ) {\r\n\r\n        let change = false;\r\n\r\n        if( this.status !== n ){\r\n\r\n            this.status = n;\r\n            let s = this.s, cc = this.colors;\r\n        \r\n            switch( n ){\r\n\r\n                case 1: this.status = 1; s[1].color = cc.text; s[0].background = 'none'; break;\r\n                case 2: this.status = 2; s[1].color = cc.textOver; s[0].background = cc.back; break;\r\n                case 3: this.status = 3; s[1].color = cc.textSelect; s[0].background = cc.select; break;\r\n                case 4: this.status = 4; s[1].color = cc.textOver; s[0].background = cc.over; break;\r\n\r\n            }\r\n\r\n            change = true;\r\n\r\n        }\r\n\r\n        return change;\r\n\r\n    }\r\n\r\n    reset () {\r\n\r\n        this.cursor();\r\n       // return this.mode( 1 );\r\n\r\n    }\r\n\r\n    selected ( b ){\r\n\r\n        if( this.isSelect ) this.mode(1);\r\n\r\n        this.isSelect = b || false;\r\n\r\n        if( this.isSelect ) this.mode(3);\r\n        \r\n    }\r\n\r\n\r\n}\n\nclass Grid extends Proto {\r\n\r\n    constructor( o = {} ) {\r\n\r\n        super( o );\r\n\r\n        this.values = o.values || [];\r\n\r\n        if( typeof this.values === 'string' ) this.values = [ this.values ];\r\n        this.lng = this.values.length;\r\n\r\n        this.value = o.value || null;\r\n\r\n\r\n        this.isSelectable = o.selectable || false;\r\n        this.spaces = o.spaces || [5,3];\r\n        this.bsize = o.bsize || [90,20];\r\n\r\n        if(o.h) this.bsize[1] = o.h;\r\n        this.bsizeMax = this.bsize[0];\r\n\r\n        \r\n        this.tmp = [];\r\n        this.stat = [];\r\n        this.grid = [ 2, Math.round( this.lng * 0.5 ) ];\r\n        this.h = this.grid[1] * ( this.bsize[1] + this.spaces[1] ) + this.spaces[1];\r\n\r\n        this.c[1].textContent = '';\r\n        this.c[2] = this.dom( 'table', this.css.basic + 'width:100%; top:'+(this.spaces[1]-2)+'px; height:auto; border-collapse:separate; border:none; border-spacing: '+(this.spaces[0]-2)+'px '+(this.spaces[1]-2)+'px;' );\r\n\r\n        let n = 0, b, td, tr, sel;\r\n\r\n        this.res = -1;\r\n        this.isDown = false;\r\n        this.neverlock = true;\r\n\r\n        this.buttons = [];\r\n        this.stat = [];\r\n        this.tmpX = [];\r\n        this.tmpY = [];\r\n\r\n        let cc = this.colors;\r\n\r\n        for( let i = 0; i < this.grid[1]; i++ ){\r\n\r\n            tr = this.c[2].insertRow();\r\n            tr.style.cssText = 'pointer-events:none;';\r\n            for( let j = 0; j < this.grid[0]; j++ ){\r\n\r\n                td = tr.insertCell();\r\n                td.style.cssText = 'pointer-events:none;';\r\n\r\n                if( this.values[n] ){\r\n\r\n                    sel = false;\r\n                    if( this.values[n] === this.value && this.isSelectable ) sel = true;\r\n\r\n                    b = document.createElement( 'div' );\r\n                    b.style.cssText = this.css.txt + this.css.button + 'position:static; width:'+this.bsize[0]+'px; height:'+this.bsize[1]+'px; border:'+cc.borderSize+'px solid '+cc.border+'; left:auto; right:auto; border-radius:'+this.radius+'px;';\r\n                    b.style.background = sel ? cc.select : cc.button;\r\n                    b.style.color = sel ? cc.textSelect : cc.text;\r\n                    b.innerHTML = this.values[n];\r\n                    td.appendChild( b );\r\n\r\n                    this.buttons.push(b);\r\n                    this.stat.push(1);\r\n\r\n                } else {\r\n\r\n                    b = document.createElement( 'div' );\r\n                    b.style.cssText = this.css.txt + 'position:static; width:'+this.bsize[0]+'px; height:'+this.bsize[1]+'px; text-align:center; left:auto; right:auto; background:none;';\r\n                    td.appendChild( b );\r\n\r\n                }\r\n\r\n                if(j===0) b.style.cssText += 'float:right;';\r\n                else b.style.cssText += 'float:left;';\r\n            \r\n                n++;\r\n\r\n            }\r\n        }\r\n\r\n        this.init();\r\n\r\n    }\r\n\r\n    testZone ( e ) {\r\n\r\n        let l = this.local;\r\n        if( l.x === -1 && l.y === -1 ) return -1;\r\n        \r\n        let tx = this.tmpX;\r\n        let ty = this.tmpY;\r\n\r\n        let id = -1;\r\n        let c = -1;\r\n        let line = -1;\r\n        let i = this.grid[0];\r\n        while( i-- ){\r\n        \tif( l.x > tx[i][0] && l.x < tx[i][1] ) c = i;\r\n        }\r\n\r\n        i = this.grid[1];\r\n        while( i-- ){\r\n            if( l.y > ty[i][0] && l.y < ty[i][1] ) line = i;\r\n        }\r\n\r\n        if(c!==-1 && line!==-1){\r\n            id = c + (line*2);\r\n            if(id>this.lng-1) id = -1;\r\n        }\r\n\r\n        return id;\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   EVENTS\r\n    // ----------------------\r\n\r\n    mouseup ( e ) {\r\n\r\n        if( !this.isDown ) return false\r\n\r\n        this.isDown = false;\r\n        if( this.res !== -1 ){\r\n            this.value = this.values[this.res];\r\n            this.send();\r\n        }\r\n\r\n        return this.mousemove( e )\r\n\r\n    }\r\n\r\n    mousedown ( e ) {\r\n\r\n        if( this.isDown ) return false\r\n        this.isDown = true;\r\n        return this.mousemove( e )\r\n\r\n    }\r\n\r\n    mousemove ( e ) {\r\n\r\n        let up = false;\r\n        this.res = this.testZone( e );\r\n\r\n        if( this.res !== -1 ){\r\n            this.cursor('pointer');\r\n            up = this.modes( this.isDown ? 3 : 2, this.res );\r\n        } else {\r\n        \tup = this.reset();\r\n        }\r\n\r\n        return up;\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   MODE\r\n    // -----------------------\r\n\r\n    modes ( N = 1, id = -1 ) {\r\n\r\n        let i = this.lng, w, n, r = false;\r\n\r\n        while( i-- ){\r\n\r\n            n = N;\r\n            w = this.isSelectable ? this.values[ i ] === this.value : false;\r\n            \r\n            if( i === id ){\r\n                if( w && n === 2 ) n = 3; \r\n            } else {\r\n                n = 1;\r\n                if( w ) n = 4;\r\n            }\r\n\r\n            if( this.mode( n, i ) ) r = true;\r\n\r\n        }\r\n\r\n        return r\r\n\r\n    }\r\n\r\n    mode ( n, id ) {\r\n\r\n        let change = false;\r\n        let cc = this.colors, s = this.buttons;\r\n        let i = id;\r\n\r\n        if( this.stat[id] !== n ){\r\n\r\n            this.stat[id] = n;\r\n        \r\n            switch( n ){\r\n\r\n                case 1: s[i].style.color = cc.text; s[i].style.background = cc.button; break;\r\n                case 2: s[i].style.color = cc.textOver; s[i].style.background = cc.overoff; break;\r\n                case 3: s[i].style.color = cc.textOver; s[i].style.background = cc.over; break;\r\n                case 4: s[i].style.color = cc.textSelect; s[i].style.background = cc.select; break;\r\n\r\n            }\r\n\r\n            change = true;\r\n\r\n        }\r\n\r\n        return change;\r\n\r\n    }\r\n\r\n    // ----------------------\r\n\r\n    reset () {\r\n\r\n        this.res = -1;\r\n        this.cursor();\r\n        return this.modes()\r\n\r\n    }\r\n\r\n\r\n    label ( string, n ) {\r\n\r\n        this.buttons[n].textContent = string;\r\n\r\n    }\r\n\r\n    icon ( string, y, n ) {\r\n\r\n        this.buttons[n].style.padding = ( y || 0 ) +'px 0px';\r\n        this.buttons[n].innerHTML = string;\r\n\r\n    }\r\n\r\n    testW () {\r\n\r\n        let vw = this.spaces[0]*3 + this.bsizeMax*2, rz = false;\r\n        if( vw > this.w ) {\r\n            this.bsize[0] = ( this.w-(this.spaces[0]*3) ) * 0.5;\r\n            rz = true;\r\n        } else {\r\n            if( this.bsize[0] !== this.bsizeMax ) {\r\n                this.bsize[0] = this.bsizeMax;\r\n                rz = true;\r\n            }\r\n        }\r\n\r\n        if( !rz ) return;\r\n\r\n        let i = this.buttons.length;\r\n        while(i--) this.buttons[i].style.width = this.bsize[0] + 'px';\r\n\r\n    }\r\n\r\n    rSize () {\r\n\r\n        super.rSize();\r\n\r\n        this.testW();\r\n\r\n        let mid;\r\n\r\n        this.tmpX = [];\r\n        this.tmpY = [];\r\n\r\n        for( let j = 0; j < this.grid[0]; j++ ){\r\n\r\n            if(j===0){\r\n                mid = ( this.w*0.5 ) - ( this.spaces[0]*0.5 );\r\n                this.tmpX.push( [ mid-this.bsize[0], mid ] );\r\n            } else {\r\n                mid = ( this.w*0.5 ) + ( this.spaces[0]*0.5 );\r\n                this.tmpX.push( [ mid, mid+this.bsize[0] ] );\r\n            }\r\n\r\n        }\r\n\r\n        mid = this.spaces[1];\r\n\r\n        for( let i = 0; i < this.grid[1]; i++ ){\r\n\r\n            this.tmpY.push( [ mid, mid + this.bsize[1] ] );\r\n            mid += this.bsize[1] + this.spaces[1];\r\n            \r\n        }\r\n\r\n    }\r\n\r\n}\n\nclass Pad2D extends Proto {\r\n\r\n    constructor( o = {} ) {\r\n\r\n        super( o );\r\n\r\n        this.autoWidth = false;\r\n        this.minw  = this.w;\r\n        this.diam = o.diam || this.w; \r\n\r\n        //this.margin = 15;\r\n        this.pos = new V2(0,0);\r\n        this.maxPos = 90;\r\n\r\n        this.model = o.stype || 0;\r\n        if( o.mode !== undefined ) this.model = o.mode;\r\n\r\n        this.min = o.min === undefined ? -1 : o.min;\r\n        this.max = o.max === undefined ? 1 : o.max;\r\n\r\n        this.range = (this.max - this.min)*0.5;  \r\n\r\n        this.cmode = 0;\r\n\r\n\r\n        //console.log(this.range)\r\n\r\n        this.c[0].style.display = 'block';\r\n\r\n        \r\n\r\n\r\n\r\n        this.precision = o.precision === undefined ? 2 : o.precision;\r\n\r\n        /*this.bounds = {};\r\n        this.bounds.x1 = o.x1 || -1;\r\n        this.bounds.x2 = o.x2 || 1;\r\n        this.bounds.y1 = o.y1 || -1;\r\n        this.bounds.y2 = o.y2 || 1;\r\n\r\n        this.lerpX = this.lerp( this.margin, this.w - this.margin , this.bounds.x1, this.bounds.x2 );\r\n        this.lerpY = this.lerp( this.margin, this.w - this.margin , this.bounds.y1, this.bounds.y2 );\r\n\r\n        this.alerpX = this.lerp( this.bounds.x1, this.bounds.x2, this.margin, this.w - this.margin );\r\n        this.alerpY = this.lerp( this.bounds.y1, this.bounds.y2, this.margin, this.w - this.margin );*/\r\n\r\n        this.value = ( Array.isArray( o.value ) && o.value.length == 2 ) ? o.value : [ 0, 0 ];\r\n        \r\n        \r\n        this.h = o.h || this.w + 10;\r\n        this.top = 0;\r\n\r\n        this.c[0].style.width = this.w + 'px';\r\n\r\n        // Title\r\n        if( this.c[1] !== undefined ) { // with title\r\n\r\n            this.c[1].style.width = '100%';\r\n            this.c[1].style.justifyContent = 'center';\r\n            this.top = 10;\r\n            this.h += 10;\r\n\r\n        }\r\n\r\n        let cc = this.colors;\r\n\r\n\r\n        // Value\r\n        this.c[2] = this.dom( 'div', this.css.txt + 'justify-content:center; top:'+ ( this.h - 20 ) + 'px; width:100%; color:' + cc.text );\r\n        this.c[2].textContent = this.value;\r\n\r\n        // Pad\r\n\r\n        let pad = this.getPad2d();\r\n\r\n        this.setSvg( pad, 'fill', cc.back, 0 );\r\n        this.setSvg( pad, 'fill', cc.button, 1 );\r\n        this.setSvg( pad, 'stroke', cc.back, 2 );\r\n        this.setSvg( pad, 'stroke', cc.back, 3 );\r\n        this.setSvg( pad, 'stroke', cc.text, 4 );\r\n\r\n        this.setSvg( pad, 'viewBox', '0 0 '+this.diam+' '+this.diam );\r\n        this.setCss( pad, { width:this.diam, height:this.diam, left:0, top:this.top });\r\n\r\n        this.c[3] = pad;\r\n\r\n        this.init();\r\n        this.setValue();\r\n\r\n    }\r\n    \r\n    testZone ( e ) {\r\n        \r\n        let l = this.local;\r\n\r\n        if( l.x === -1 && l.y === -1 ) return '';\r\n\r\n        if( l.y <= this.c[ 1 ].offsetHeight ) return 'title';\r\n        else if ( l.y > this.h - this.c[ 2 ].offsetHeight ) return 'text';\r\n        else return 'pad';\r\n\r\n        /*if( ( l.x >= this.margin ) && ( l.x <= this.w - this.margin ) && ( l.y >= this.top + this.margin ) && ( l.y <= this.top + this.w - this.margin ) ) {\r\n            return 'pad';\r\n        }*/\r\n        \r\n        //return '';\r\n\r\n    }\r\n\r\n    mouseup ( e ) {\r\n\r\n        this.isDown = false;\r\n        return this.mode(0);\r\n    \r\n    }\r\n\r\n    mousedown ( e ) {\r\n\r\n        if ( this.testZone(e) === 'pad' ) {\r\n\r\n            this.isDown = true;\r\n            this.mousemove( e );\r\n            return this.mode(1);\r\n        }\r\n\r\n    }\r\n\r\n    mousemove ( e ) {\r\n\r\n        if( !this.isDown ) return;\r\n\r\n        let x = (this.w*0.5) - ( e.clientX - this.zone.x );\r\n        let y = (this.diam*0.5) - ( e.clientY - this.zone.y - this.top );\r\n        let r = 256 / this.diam;\r\n\r\n        x = -(x*r);\r\n        y = -(y*r);\r\n\r\n        x = Tools.clamp( x, -this.maxPos, this.maxPos );\r\n        y = Tools.clamp( y, -this.maxPos, this.maxPos );\r\n\r\n        //let x = e.clientX - this.zone.x;\r\n        //let y = e.clientY - this.zone.y - this.top;\r\n\r\n        /*if( x < this.margin ) x = this.margin;\r\n        if( x > this.w - this.margin ) x = this.w - this.margin;\r\n        if( y < this.margin ) y = this.margin;\r\n        if( y > this.w - this.margin ) y = this.w - this.margin;*/\r\n\r\n        //console.log(x,y)\r\n\r\n        this.setPos( [ x , y ] );\r\n        \r\n        this.update( true );\r\n\r\n    }\r\n\r\n    mode ( mode ) {\r\n\r\n        if( this.cmode === mode ) return false;\r\n\r\n        let cc = this.colors;\r\n\r\n        switch( mode ){\r\n            case 0: // base\r\n\r\n                this.s[2].color = cc.text;\r\n                this.setSvg( this.c[3], 'fill', cc.back, 0);\r\n                this.setSvg( this.c[3], 'fill', cc.button, 1);\r\n                this.setSvg( this.c[3], 'stroke', cc.back, 2);\r\n                this.setSvg( this.c[3], 'stroke', cc.back, 3);\r\n                this.setSvg( this.c[3], 'stroke', cc.text, 4 );\r\n                \r\n            break;\r\n            case 1: // down\r\n\r\n                this.s[2].color = cc.textSelect;\r\n                this.setSvg( this.c[3], 'fill', cc.backoff, 0);\r\n                this.setSvg( this.c[3], 'fill', cc.overoff, 1);\r\n                this.setSvg( this.c[3], 'stroke', cc.backoff, 2);\r\n                this.setSvg( this.c[3], 'stroke', cc.backoff, 3);\r\n                this.setSvg( this.c[3], 'stroke', cc.textSelect, 4 );\r\n                \r\n            break;\r\n        }\r\n\r\n        this.cmode = mode;\r\n        return true;\r\n\r\n\r\n\r\n    }\r\n\r\n    update ( up ) {\r\n\r\n        //if( up === undefined ) up = true;\r\n        \r\n        this.c[2].textContent = this.value;\r\n\r\n        this.updateSVG();\r\n\r\n        if( up ) this.send();\r\n\r\n    }\r\n\r\n    updateSVG() {\r\n\r\n        if ( this.model == 1 ) {\r\n\r\n            this.setSvg( this.c[3], 'y1', this.pos.y, 2 );\r\n            this.setSvg( this.c[3], 'y2', this.pos.y, 2 );\r\n\r\n            this.setSvg( this.c[3], 'x1', this.pos.x, 3 );\r\n            this.setSvg( this.c[3], 'x2', this.pos.x, 3 );\r\n\r\n        }\r\n\r\n        this.setSvg( this.c[3], 'cx', this.pos.x, 4 );\r\n        this.setSvg( this.c[3], 'cy', this.pos.y, 4 );\r\n\r\n    }\r\n\r\n    setPos ( p ) {\r\n\r\n        //if( p === undefined ) p = [ this.w / 2, this.w / 2 ];\r\n\r\n        this.pos.set( p[0]+128 , p[1]+128 );\r\n\r\n        let r = 1/this.maxPos;\r\n\r\n        this.value[0] = ((p[0]*r)*this.range).toFixed( this.precision );\r\n        this.value[1] = ((p[1]*r)*this.range).toFixed( this.precision );\r\n\r\n    }\r\n\r\n    setValue ( v, up = false ) {\r\n\r\n        if( v === undefined ) v = this.value;\r\n\r\n        /*if ( v[0] < this.bounds.x1 ) v[0] = this.bounds.x1;\r\n        if ( v[0] > this.bounds.x2 ) v[0] = this.bounds.x2;\r\n        if ( v[1] < this.bounds.y1 ) v[1] = this.bounds.y1;\r\n        if ( v[1] > this.bounds.y2 ) v[1] = this.bounds.y2;*/\r\n\r\n        this.value[0] = Math.min( this.max, Math.max( this.min, v[0] ) ).toFixed( this.precision ) * 1;\r\n        this.value[1] = Math.min( this.max, Math.max( this.min, v[1] ) ).toFixed( this.precision ) * 1;\r\n\r\n        this.pos.set( ((this.value[0]/this.range)*this.maxPos)+128  , ((this.value[1]/this.range)*this.maxPos)+128 );\r\n\r\n        //console.log(this.pos)\r\n\r\n        this.update( up );\r\n\r\n    }\r\n\r\n    /*lerp( s1, s2, d1, d2, c = true ) {\r\n\r\n        let s = ( d2 - d1 ) / ( s2 - s1 );\r\n\r\n        return c ? ( v ) => { \r\n            return ( ( v < s1 ? s1 : v > s2 ? s2 : v ) - s1 ) * s + d1\r\n        } : ( v ) => { \r\n          return ( v - s1 ) * s + d1\r\n        }\r\n\r\n    }*/\r\n\r\n}\n\nconst add = function () {\r\n\r\n        let a = arguments; \r\n\r\n        let type, o, ref = false, n = null;\r\n\r\n        if( typeof a[0] === 'string' ){ \r\n\r\n            type = a[0];\r\n            o = a[1] || {};\r\n\r\n        } else if ( typeof a[0] === 'object' ){ // like dat gui\r\n\r\n            ref = true;\r\n            if( a[2] === undefined ) [].push.call(a, {});\r\n                \r\n            type = a[2].type ? a[2].type : autoType( a[0][a[1]], a[2] );\r\n\r\n            o = a[2];\r\n            o.name = a[1];\r\n            if( type === 'list' ){ o.list = a[0][a[1]]; }\r\n            else o.value = a[0][a[1]];\r\n\r\n        }\r\n\r\n        \r\n\r\n        let name = type.toLowerCase();\r\n\r\n        if( name === 'group' ) o.add = add;\r\n\r\n        switch( name ){\r\n\r\n            case 'bool': case 'boolean': n = new Bool(o); break;\r\n            case 'button': n = new Button(o); break;\r\n            case 'circular': n = new Circular(o); break;\r\n            case 'color': n = new Color(o); break;\r\n            case 'fps': n = new Fps(o); break;\r\n            case 'graph': n = new Graph(o); break;\r\n            case 'group': n = new Group(o); break;\r\n            case 'joystick': n = new Joystick(o); break;\r\n            case 'knob': n = new Knob(o); break;\r\n            case 'list': n = new List(o); break;\r\n            case 'numeric': case 'number': n = new Numeric(o); break;\r\n            case 'slide': n = new Slide(o); break;\r\n            case 'textInput': case 'string': n = new TextInput(o); break;\r\n            case 'title': case 'text': n = new Title(o); break;\r\n            case 'select': n = new Select(o); break;\r\n            case 'selector': n = new Selector(o); break;\r\n            case 'empty': case 'space': n = new Empty(o); break;\r\n            case 'item': n = new Item(o); break;\r\n            case 'grid': n = new Grid(o); break;\r\n            case 'pad2d': case 'pad': n = new Pad2D(o); break;\r\n\r\n        }\r\n\r\n        if( n !== null ){\r\n\r\n            if( ref ) n.setReferency( a[0], a[1] );\r\n            return n;\r\n\r\n        }\r\n\r\n};\r\n\r\nconst autoType = function ( v, o ) {\r\n\r\n    let type = 'slide';\r\n\r\n    if( typeof v === 'boolean' ) type = 'bool'; \r\n    else if( typeof v === 'string' ){ \r\n\r\n        if( v.substring(0,1) === '#' ) type = 'color';\r\n        else type = 'string'; \r\n\r\n    } else if( typeof v === 'number' ){ \r\n\r\n        if( o.ctype ) type = 'color';\r\n        else type = 'slide';\r\n\r\n    } else if( typeof v === 'array' && v instanceof Array ){\r\n\r\n        if( typeof v[0] === 'number' ) type = 'number';\r\n        else if( typeof v[0] === 'string' ) type = 'list';\r\n\r\n    } else if( typeof v === 'object' && v instanceof Object ){\r\n\r\n        if( v.x !== undefined ) type = 'number';\r\n        else type = 'list';\r\n\r\n    }\r\n\r\n    return type\r\n\r\n};\n\n/**\r\n * @author lth / https://github.com/lo-th\r\n */\r\n\r\nclass Gui {\r\n\r\n    constructor( o = {} ) {\r\n\r\n        this.isGui = true;\r\n\r\n        this.name = 'gui';\r\n\r\n        // for 3d\r\n        this.canvas = null;\r\n        this.screen = null;\r\n        this.plane = o.plane || null;\r\n\r\n        \r\n\r\n        // color\r\n        if( o.config ) o.colors = o.config;\r\n        \r\n        if ( o.colors ) this.setConfig( o.colors );\r\n        else this.colors = Tools.defineColor( o );\r\n\r\n        // style\r\n        this.css = Tools.cloneCss();\r\n\r\n        this.isReset = true;\r\n        this.tmpAdd = null;\r\n        //this.tmpH = 0\r\n\r\n        this.isCanvas = o.isCanvas || false;\r\n        this.isCanvasOnly = false;\r\n        \r\n        this.callback = o.callback  === undefined ? null : o.callback;\r\n\r\n        this.forceHeight = o.maxHeight || 0;\r\n        this.lockHeight = o.lockHeight || false;\r\n\r\n        this.isItemMode = o.itemMode !== undefined ? o.itemMode : false;\r\n\r\n        this.cn = '';\r\n        \r\n        // size define\r\n        this.size = Tools.size;\r\n        if( o.p !== undefined ) this.size.p = o.p;\r\n        if( o.w !== undefined ) this.size.w = o.w;\r\n        if( o.h !== undefined ) this.size.h = o.h;\r\n        if( o.s !== undefined ) this.size.s = o.s;\r\n\r\n        this.size.h = this.size.h < 11 ? 11 : this.size.h;\r\n\r\n        // local mouse and zone\r\n        this.local = new V2().neg();\r\n        this.zone = { x:0, y:0, w:this.size.w, h:0 };\r\n\r\n        // virtual mouse\r\n        this.mouse = new V2().neg();\r\n\r\n        this.h = 0;\r\n        //this.prevY = -1;\r\n        this.sw = 0;\r\n\r\n        \r\n\r\n        // bottom and close height\r\n        this.isWithClose = o.close !== undefined ? o.close : true;\r\n        this.bh = !this.isWithClose ? 0 : this.size.h;\r\n\r\n        this.autoResize = o.autoResize === undefined ? true : o.autoResize;\r\n\r\n        // default position\r\n        this.isCenter = o.center || false;\r\n        this.cssGui = o.css !== undefined ? o.css : (this.isCenter ? '' : 'right:10px;');\r\n\r\n        this.isOpen = o.open !== undefined ? o.open : true;\r\n        this.isDown = false;\r\n        this.isScroll = false;\r\n\r\n        this.uis = [];\r\n        this.current = -1;\r\n        this.proto = null;\r\n        this.isEmpty = true;\r\n        this.decal = 0;\r\n        this.ratio = 1;\r\n        this.oy = 0;\r\n\r\n\r\n        this.isNewTarget = false;\r\n\r\n        let cc = this.colors;\r\n\r\n        this.content = Tools.dom( 'div', this.css.basic + ' width:0px; height:auto; top:0px; background:'+cc.content+'; ' + this.cssGui );\r\n\r\n        this.innerContent = Tools.dom( 'div', this.css.basic + 'width:100%; top:0; left:0; height:auto; overflow:hidden;');\r\n        //this.innerContent = Tools.dom( 'div', this.css.basic + this.css.button + 'width:100%; top:0; left:0; height:auto; overflow:hidden;');\r\n        this.content.appendChild( this.innerContent );\r\n\r\n        //this.inner = Tools.dom( 'div', this.css.basic + 'width:100%; left:0; ')\r\n        this.useFlex = true; \r\n        let flexible = this.useFlex ? 'display:flex; flex-flow: row wrap;' : ''; //' display:flex; justify-content:start; align-items:start;flex-direction: column; justify-content: center; align-items: center;';\r\n        this.inner = Tools.dom( 'div', this.css.basic + flexible + 'width:100%; left:0; ');\r\n        this.innerContent.appendChild(this.inner);\r\n\r\n        // scroll\r\n        this.scrollBG = Tools.dom( 'div', this.css.basic + 'right:0; top:0; width:'+ (this.size.s - 1) +'px; height:10px; display:none; background:'+cc.background+';');\r\n        this.content.appendChild( this.scrollBG );\r\n\r\n        this.scroll = Tools.dom( 'div', this.css.basic + 'background:'+cc.button+'; right:2px; top:0; width:'+(this.size.s-4)+'px; height:10px;');\r\n        this.scrollBG.appendChild( this.scroll );\r\n\r\n        // bottom button\r\n        this.bottomText = o.bottomText || ['open', 'close'];\r\n\r\n        let r = cc.radius;\r\n        this.bottom = Tools.dom( 'div',  this.css.txt + 'width:100%; top:auto; bottom:0; left:0; border-bottom-right-radius:'+r+'px; border-bottom-left-radius:'+r+'px; justify-content:center; height:'+this.bh+'px; line-height:'+(this.bh-5)+'px; color:' + cc.text+';' );// border-top:1px solid '+Tools.colors.stroke+';');\r\n        this.content.appendChild( this.bottom );\r\n        this.bottom.textContent = this.isOpen ? this.bottomText[1] : this.bottomText[0];\r\n        this.bottom.style.background = cc.background;\r\n\r\n        //\r\n\r\n        this.parent = o.parent !== undefined ? o.parent : null;\r\n        this.parent = o.target !== undefined ? o.target : this.parent;\r\n        \r\n        if( this.parent === null && !this.isCanvas ){ \r\n        \tthis.parent = document.body;\r\n        }\r\n\r\n        if( this.parent !== null ) this.parent.appendChild( this.content );\r\n\r\n        if( this.isCanvas && this.parent === null ) this.isCanvasOnly = true;\r\n\r\n        if( !this.isCanvasOnly ){ \r\n            this.content.style.pointerEvents = 'auto';\r\n        } else {\r\n            this.content.style.left = '0px';\r\n            this.content.style.right = 'auto';\r\n            o.transition = 0;\r\n        }\r\n\r\n\r\n        // height transition\r\n        this.transition = o.transition || Tools.transition;\r\n        if( this.transition ) setTimeout( this.addTransition.bind( this ), 0 );\r\n        \r\n\r\n        this.setWidth();\r\n\r\n        if( this.isCanvas ) this.makeCanvas();\r\n\r\n        Roots.add( this );\r\n\r\n    }\r\n\r\n    setTop( t, h ) {\r\n\r\n        this.content.style.top = t + 'px';\r\n        if( h !== undefined ) this.forceHeight = h;\r\n        this.calc();\r\n\r\n        Roots.needReZone = true;\r\n\r\n    }\r\n\r\n    addTransition(){\r\n\r\n        if( this.transition && !this.isCanvas ){\r\n            this.innerContent.style.transition = 'height '+this.transition+'s ease-out';\r\n            this.content.style.transition = 'height '+this.transition+'s ease-out';\r\n            this.bottom.style.transition = 'top '+this.transition+'s ease-out';\r\n            //this.bottom.addEventListener(\"transitionend\", Roots.resize, true);\r\n        }\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   CANVAS\r\n    // ----------------------\r\n\r\n    onDraw () {}\r\n\r\n    makeCanvas () {\r\n\r\n    \tthis.canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', \"canvas\" );\r\n    \tthis.canvas.width = this.zone.w;\r\n    \tthis.canvas.height = this.forceHeight ? this.forceHeight : this.zone.h;\r\n\r\n        //console.log( this.canvas.width, this.canvas.height )\r\n\r\n    }\r\n\r\n    draw ( force ) {\r\n\r\n    \tif( this.canvas === null ) return;\r\n\r\n    \tlet w = this.zone.w;\r\n    \tlet h = this.forceHeight ? this.forceHeight : this.zone.h;\r\n    \tRoots.toCanvas( this, w, h, force );\r\n\r\n    }\r\n\r\n    //////\r\n\r\n    getDom () {\r\n\r\n        return this.content;\r\n\r\n    }\r\n\r\n    noMouse () {\r\n\r\n        this.mouse.neg();\r\n\r\n    }\r\n\r\n    setMouse ( uv, flip = true ) {\r\n\r\n        if(flip) this.mouse.set( Math.round( uv.x * this.canvas.width ), this.canvas.height - Math.round( uv.y * this.canvas.height ) );\r\n        else this.mouse.set( Math.round( uv.x * this.canvas.width ), Math.round( uv.y * this.canvas.height ) );\r\n        //this.mouse.set( m.x, m.y );\r\n\r\n    }\r\n\r\n    setConfig ( o ) {\r\n\r\n        // reset to default text \r\n        Tools.setText();\r\n        this.colors = Tools.defineColor( o );\r\n\r\n    }\r\n\r\n    setColors ( o ) {\r\n\r\n        for( let c in o ){\r\n            if( this.colors[c] ) this.colors[c] = o[c];\r\n        }\r\n\r\n    }\r\n\r\n    setText ( size, color, font, shadow ) {\r\n\r\n        Tools.setText( size, color, font, shadow );\r\n\r\n    }\r\n\r\n    hide ( b ) {\r\n        this.content.style.visibility = b ? 'hidden' : 'visible'; \r\n    }\r\n\r\n    display( v = false ) {\r\n        this.content.style.visibility = v ? 'visible' : 'hidden';\r\n    }\r\n\r\n    onChange ( f ) {\r\n\r\n        this.callback = f || null;\r\n        return this;\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   STYLES\r\n    // ----------------------\r\n\r\n    mode ( n ) {\r\n\r\n    \tlet needChange = false;\r\n        let cc = this.colors;\r\n\r\n    \tif( n !== this.cn ){\r\n\r\n\t    \tthis.cn = n;\r\n\r\n\t    \tswitch( n ){\r\n\r\n\t    \t\tcase 'def':\r\n                   Roots.cursor();\r\n\t    \t\t   this.scroll.style.background = cc.button; \r\n\t    \t\t   this.bottom.style.background = cc.background;\r\n\t    \t\t   this.bottom.style.color = cc.text;\r\n\t    \t\tbreak;\r\n\r\n\t    \t\t//case 'scrollDef': this.scroll.style.background = this.colors.scroll; break;\r\n\t    \t\tcase 'scrollOver': \r\n                    Roots.cursor('ns-resize');\r\n                    this.scroll.style.background = cc.select;\r\n                break;\r\n\t    \t\tcase 'scrollDown': \r\n                    this.scroll.style.background = cc.select;\r\n                break;\r\n\r\n\t    \t\t//case 'bottomDef': this.bottom.style.background = this.colors.background; break;\r\n\t    \t\tcase 'bottomOver': \r\n                    Roots.cursor('pointer');\r\n                    this.bottom.style.background = cc.backgroundOver; \r\n                    this.bottom.style.color = cc.textOver; \r\n                break;\r\n\t    \t\t//case 'bottomDown': this.bottom.style.background = this.colors.select; this.bottom.style.color = '#000'; break;\r\n\r\n\t    \t}\r\n\r\n\t    \tneedChange = true;\r\n\r\n\t    }\r\n\r\n    \treturn needChange;\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   TARGET\r\n    // ----------------------\r\n\r\n    clearTarget () {\r\n\r\n    \tif( this.current === -1 ) return false;\r\n        if( this.proto.s ){\r\n            // if no s target is delete !!\r\n            this.proto.uiout();\r\n            this.proto.reset();\r\n        }\r\n        \r\n        this.proto = null;\r\n        this.current = -1;\r\n\r\n        ///console.log(this.isDown)//if(this.isDown)Roots.clearInput();\r\n\r\n        \r\n\r\n        Roots.cursor();\r\n        return true;\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   ZONE TEST\r\n    // ----------------------\r\n\r\n    testZone ( e ) {\r\n\r\n        let l = this.local;\r\n        if( l.x === -1 && l.y === -1 ) return '';\r\n\r\n        this.isReset = false;\r\n\r\n        let name = '';\r\n\r\n        let s = this.isScroll ?  this.zone.w - this.size.s : this.zone.w;\r\n        \r\n        if( l.y > this.zone.h - this.bh &&  l.y < this.zone.h ) name = 'bottom';\r\n        else name = l.x > s ? 'scroll' : 'content';\r\n\r\n        return name;\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   EVENTS\r\n    // ----------------------\r\n\r\n    handleEvent ( e ) {\r\n\r\n    \tlet type = e.type;\r\n\r\n    \tlet change = false;\r\n    \tlet protoChange = false;\r\n\r\n    \tlet name = this.testZone( e );\r\n\r\n    \tif( type === 'mouseup' && this.isDown ) this.isDown = false;\r\n    \tif( type === 'mousedown' && !this.isDown ) this.isDown = true;\r\n\r\n        if( this.isDown && this.isNewTarget ){ Roots.clearInput(); this.isNewTarget=false; }\r\n\r\n    \tif( !name ) return;\r\n\r\n    \tswitch( name ){\r\n\r\n    \t\tcase 'content':\r\n\r\n                e.clientY = this.isScroll ?  e.clientY + this.decal : e.clientY;\r\n\r\n                if( Roots.isMobile && type === 'mousedown' ) this.getNext( e, change );\r\n\r\n\t    \t\tif( this.proto ) protoChange = this.proto.handleEvent( e );\r\n\r\n\t    \t\tif( type === 'mousemove' ) change = this.mode('def');\r\n                if( type === 'wheel' && !protoChange && this.isScroll ) change = this.onWheel( e );\r\n               \r\n\t    \t\tif( !Roots.lock ) {\r\n                    this.getNext( e, change );\r\n                }\r\n\r\n    \t\tbreak;\r\n    \t\tcase 'bottom':\r\n\r\n\t    \t\tthis.clearTarget();\r\n\t    \t\tif( type === 'mousemove' ) change = this.mode('bottomOver');\r\n\t    \t\tif( type === 'mousedown' ) {\r\n\t    \t\t\tthis.isOpen = this.isOpen ? false : true;\r\n\t\t            this.bottom.textContent = this.isOpen ? this.bottomText[1] : this.bottomText[0];\r\n\t\t            //this.setHeight();\r\n                    this.calc();\r\n\t\t            this.mode('def');\r\n\t\t            change = true;\r\n\t    \t\t}\r\n\r\n    \t\tbreak;\r\n    \t\tcase 'scroll':\r\n\r\n\t    \t\tthis.clearTarget();\r\n\t    \t\tif( type === 'mousemove' ) change = this.mode('scrollOver');\r\n\t    \t\tif( type === 'mousedown' ) change = this.mode('scrollDown'); \r\n                if( type === 'wheel' ) change = this.onWheel( e ); \r\n\t    \t\tif( this.isDown ) this.update( (e.clientY-this.zone.y)-(this.sh*0.5) );\r\n\r\n    \t\tbreak;\r\n\r\n\r\n    \t}\r\n\r\n    \tif( this.isDown ) change = true;\r\n    \tif( protoChange ) change = true;\r\n\r\n        if( type === 'keyup' ) change = true;\r\n        if( type === 'keydown' ) change = true;\r\n\r\n    \tif( change ) this.draw();\r\n\r\n    }\r\n\r\n    getNext ( e, change ) {\r\n\r\n\r\n\r\n        let next = Roots.findTarget( this.uis, e );\r\n\r\n        if( next !== this.current ){\r\n            this.clearTarget();\r\n            this.current = next;\r\n\r\n            this.isNewTarget = true;\r\n\r\n        }\r\n\r\n        if( next !== -1 ){ \r\n            this.proto = this.uis[ this.current ];\r\n            this.proto.uiover();\r\n        }\r\n\r\n    }\r\n\r\n    onWheel ( e ) {\r\n\r\n        this.oy += 20*e.delta;\r\n        this.update( this.oy );\r\n        return true;\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   RESET\r\n    // ----------------------\r\n\r\n    reset ( force ) {\r\n\r\n        if( this.isReset ) return;\r\n\r\n        //this.resetItem();\r\n\r\n        this.mouse.neg();\r\n        this.isDown = false;\r\n\r\n        //Roots.clearInput();\r\n        let r = this.mode('def');\r\n        let r2 = this.clearTarget();\r\n\r\n        if( r || r2 ) this.draw( true );\r\n\r\n        this.isReset = true;\r\n\r\n        //Roots.lock = false;\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   ADD NODE\r\n    // ----------------------\r\n\r\n    add () {\r\n\r\n        let a = arguments;\r\n        let ontop = false;\r\n\r\n        if( typeof a[1] === 'object' ){ \r\n\r\n            a[1].isUI = true;\r\n            a[1].main = this;\r\n\r\n            ontop = a[1].ontop ? a[1].ontop : false;\r\n\r\n        } else if( typeof a[1] === 'string' ){\r\n\r\n            if( a[2] === undefined ) [].push.call(a, { isUI:true, main:this });\r\n            else {\r\n                a[2].isUI = true;\r\n                a[2].main = this;\r\n                //ontop = a[1].ontop ? a[1].ontop : false;\r\n                ontop = a[2].ontop ? a[2].ontop : false;\r\n            }\r\n            \r\n        } \r\n\r\n        let u = add.apply( this, a );\r\n\r\n        if( u === null ) return;\r\n\r\n        if( ontop ) this.uis.unshift( u );\r\n        else this.uis.push( u );\r\n\r\n        this.calc();\r\n\r\n        this.isEmpty = false;\r\n\r\n        return u\r\n\r\n    }\r\n\r\n    // remove one node\r\n\r\n    remove ( n ) {\r\n\r\n        if( n.dispose ) n.dispose();\r\n\r\n    }\r\n\r\n    // call after uis clear\r\n\r\n    clearOne ( n ) { \r\n\r\n        let id = this.uis.indexOf( n ); \r\n        if ( id !== -1 ) {\r\n            //this.calc( - (this.uis[ id ].h + 1 ) );\r\n            this.inner.removeChild( this.uis[ id ].c[0] );\r\n            this.uis.splice( id, 1 );\r\n            this.calc(); \r\n        }\r\n\r\n    }\r\n\r\n    // clear all gui\r\n\r\n    empty() {\r\n\r\n        //this.close();\r\n\r\n        let i = this.uis.length, item;\r\n\r\n        while( i-- ){\r\n            item = this.uis.pop();\r\n            this.inner.removeChild( item.c[0] );\r\n            item.dispose();\r\n        }\r\n\r\n        this.uis = [];\r\n        this.isEmpty = true;\r\n        this.calc();\r\n\r\n    }\r\n\r\n    clear() {\r\n\r\n        this.empty();\r\n\r\n    }\r\n\r\n    dispose() {\r\n\r\n        this.clear();\r\n        if( this.parent !== null ) this.parent.removeChild( this.content );\r\n        Roots.remove( this );\r\n\r\n    }\r\n\r\n\r\n    // ----------------------\r\n    //   ITEMS SPECIAL\r\n    // ----------------------\r\n\r\n    resetItem () {\r\n\r\n        if( !this.isItemMode ) return;\r\n\r\n        let i = this.uis.length;\r\n        while(i--) this.uis[i].selected();\r\n\r\n    }\r\n\r\n    setItem ( name ) {\r\n\r\n        if( !this.isItemMode ) return;\r\n\r\n        name = name || '';\r\n        this.resetItem();\r\n\r\n        if( !name ){\r\n            this.update(0);\r\n            return\r\n        } \r\n\r\n        let i = this.uis.length;\r\n        while(i--){ \r\n            if( this.uis[i].value === name ){ \r\n                this.uis[i].selected( true );\r\n                if( this.isScroll ) this.update( ( i*(this.uis[i].h+1) )*this.ratio );\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    // ----------------------\r\n    //   SCROLL\r\n    // ----------------------\r\n\r\n    upScroll ( b ) {\r\n\r\n        this.sw = b ? this.size.s : 0;\r\n        this.oy = b ? this.oy : 0;\r\n        this.scrollBG.style.display = b ? 'block' : 'none';\r\n\r\n        if( b ){\r\n\r\n            this.total = this.h;\r\n\r\n            this.maxView = this.maxHeight;\r\n\r\n            this.ratio = this.maxView / this.total;\r\n            this.sh = this.maxView * this.ratio;\r\n\r\n            this.range = this.maxView - this.sh;\r\n\r\n            this.oy = Tools.clamp( this.oy, 0, this.range );\r\n\r\n            this.scrollBG.style.height = this.maxView + 'px';\r\n            this.scroll.style.height = this.sh + 'px';\r\n\r\n        }\r\n\r\n        this.setItemWidth( this.zone.w - this.sw );\r\n        this.update( this.oy );\r\n\r\n    }\r\n\r\n    update ( y ) {\r\n\r\n        y = Tools.clamp( y, 0, this.range );\r\n\r\n        this.decal = Math.floor( y / this.ratio );\r\n        this.inner.style.top = - this.decal + 'px';\r\n        this.scroll.style.top = Math.floor( y ) + 'px';\r\n        this.oy = y;\r\n\r\n    }\r\n\r\n    // ----------------------\r\n    //   RESIZE FUNCTION\r\n    // ----------------------\r\n\r\n    calcUis() {\r\n        \r\n        return Roots.calcUis( this.uis, this.zone, this.zone.y )\r\n    }\r\n\r\n    calc() {\r\n\r\n        clearTimeout( this.tmp );\r\n        this.tmp = setTimeout( this.setHeight.bind( this ), 10 );\r\n\r\n    }\r\n\r\n    setHeight() {\r\n\r\n        if( this.tmp ) clearTimeout( this.tmp );\r\n\r\n        this.zone.h = this.bh;\r\n        this.isScroll = false;\r\n\r\n        if( this.isOpen ){\r\n\r\n            this.h = this.calcUis();\r\n\r\n            let hhh = this.forceHeight ? this.forceHeight + this.zone.y : window.innerHeight;\r\n\r\n            this.maxHeight = hhh - this.zone.y - this.bh;\r\n\r\n            let diff = this.h - this.maxHeight;\r\n\r\n            if( diff > 1 ){\r\n\r\n                this.isScroll = true;\r\n                this.zone.h = this.maxHeight + this.bh;\r\n\r\n            } else {\r\n\r\n                this.zone.h = this.h + this.bh;\r\n                \r\n            }\r\n\r\n        }\r\n\r\n        this.upScroll( this.isScroll );\r\n\r\n        this.innerContent.style.height = this.zone.h - this.bh + 'px';\r\n        this.content.style.height = this.zone.h + 'px';\r\n        this.bottom.style.top = this.zone.h - this.bh + 'px';\r\n\r\n\r\n        if( this.forceHeight && this.lockHeight ) this.content.style.height = this.forceHeight + 'px';\r\n\r\n        if( this.isCanvas ) this.draw( true );\r\n\r\n    }\r\n\r\n    rezone () {\r\n        Roots.needReZone = true;\r\n    }\r\n\r\n    setWidth ( w ) {\r\n\r\n        if( w ) this.zone.w = w;\r\n\r\n        this.zone.w = Math.floor( this.zone.w );\r\n\r\n        this.content.style.width = this.zone.w + 'px';\r\n\r\n        if( this.isCenter ) this.content.style.marginLeft = -(Math.floor(this.zone.w*0.5)) + 'px';\r\n\r\n        this.setItemWidth( this.zone.w - this.sw );\r\n\r\n    }\r\n\r\n    setItemWidth ( w ) {\r\n\r\n        let i = this.uis.length;\r\n        while(i--){\r\n            this.uis[i].setSize( w );\r\n            this.uis[i].rSize();\r\n        }\r\n\r\n    }\r\n\r\n}\n\nconst REVISION = '4.1.0';\n\n\n\n\n//# sourceURL=webpack:///./node_modules/uil/build/uil.module.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/harmony-module.js?");

/***/ })

}]);